<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python数据类型常用操作方式</title>
    <url>/id_1/</url>
    <content><![CDATA[<h3 id="python常用数据类型">
          <a href="#python常用数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#python常用数据类型" class="headerlink" title="python常用数据类型"></a>python常用数据类型</h3>
      <ul>
<li>数字</li>
<li>字符串</li>
<li>列表</li>
<li>元祖</li>
<li>字典</li>
<li>集合<a id="more"></a>



</li>
</ul>

        <h4 id="列表常用方法">
          <a href="#列表常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h4>
      <p>append ：用于在列表末尾添加新的元素<br>extent : 合并两个列表<br>insert : 将元素插入到列表指定位置<br>count : 统计某个元素在列表中出现的次数<br>index : 用于从列表中找出来某个值第一个匹配项的位置<br>reverse ： 将列表中的元素反向存放<br>sort  ：对列表进行排序</p>
<blockquote>
<p>sort和sorted的区别是什么？<br>sort是用来对列表进行排序的(无返回值)，而sorted可以对所有可迭代对象排序(返回一个新的列表)</p>
</blockquote>
<p>pop : 删除列表末尾元素<br>remove ：移除列表中某个值的第一个匹配项</p>

        <h4 id="字符串常用方法">
          <a href="#字符串常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4>
      <p>find：找个某个字符串第一次出现的位置<br>join：拼接字符串(逆方法  split)<br>split：拆分字符串<br>strip：去除首尾空格<br>replace：替换字符串<br>count：查询某个字符在字符串中出现的次数</p>

        <h4 id="字典的常用方法">
          <a href="#字典的常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#字典的常用方法" class="headerlink" title="字典的常用方法"></a>字典的常用方法</h4>
      <p>clear：清空字典<br>fromkeys：创建一个新字典，序列元素作为键，值为默认值<br>get：获取指定键的值<br>setdefault：获取指定键的值，如果键不存在那么添加一个新的键值对<br>pop：删除指定键的值**<br>update：更新字典，可以用来合并字典<br>keys:返回一个包含所有键的列表<br>values:返回一个包含所有值的列表<br>items:返回一个包含所有键值对的列表</p>

        <h4 id="集合常用方法">
          <a href="#集合常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h4>
      <p>add：添加<br>clear：清空集合<br>update：合并集合<br>pop：随机删除一个元素</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">POP删除元素其实是有规律可循的：</span><br><span class="line"># 元素是数字时, 删除最小的数字, 其余数字升序排列</span><br><span class="line"># 元素非数字时, 随机删除一个元素, 其余元素随机排序</span><br><span class="line"># 元素既有数字又含非数字时, 如果删除的是数字, 则一定删最小的, 否则随机删除一个非数字元素</span><br></pre></td></tr></tbody></table></div></figure>
<p>set：去重<br>intersection：交集<br>union：并集<br>difference：差集</p>

        <h4 id="元祖常用方法">
          <a href="#元祖常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#元祖常用方法" class="headerlink" title="元祖常用方法"></a>元祖常用方法</h4>
      <p>cmp(tuple1, tuple2)：比较两个元组元素。<br>len(tuple)：计算元组元素个数。<br>max(tuple)：返回元组中元素最大值。<br>min(tuple)：返回元组中元素最小值。<br>tuple(seq)：将列表转换为元组。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>WebShell</title>
    <url>/id_10/</url>
    <content><![CDATA[<h3 id="什么是Webshell">
          <a href="#什么是Webshell" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是Webshell" class="headerlink" title="什么是Webshell?"></a>什么是Webshell?</h3>
      <p>顾名思义，”web” - 显然需要服务器开放web服务,”shell” - 取得对服务器某种程度上操作权限。<br>webshell常常被称为匿名用户(入侵者)通过WEB服务端口对WEB服务器有某种程度上操作的权限,由于其大多是以网页脚本的形式出现，也有人称之为网站后门工具。</p>
<a id="more"></a>


        <h3 id="Webshell有什么作用？">
          <a href="#Webshell有什么作用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Webshell有什么作用？" class="headerlink" title="Webshell有什么作用？"></a>Webshell有什么作用？</h3>
      <ul>
<li>一方面，webshell被站长常常用于网站管理、服务器管理等等，根据FSO权限的不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。</li>
<li>另一方面，被入侵者利用，从而达到控制网站服务器的目的。这些网页脚本常称为WEB脚本木马，目前比较流行的asp或php木马，也有基于.NET的脚本木马。</li>
</ul>

        <h3 id="使用VUE-Django-实现Webshell">
          <a href="#使用VUE-Django-实现Webshell" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用VUE-Django-实现Webshell" class="headerlink" title="使用VUE+Django 实现Webshell"></a>使用VUE+Django 实现Webshell</h3>
      <p>web端使用Xterm.js或者其他的WebShell组件和websocket<br>后端只需要支持WebSocket和SSH协议的远程登录模块即可</p>

        <h4 id="Web-VUE-端实现">
          <a href="#Web-VUE-端实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#Web-VUE-端实现" class="headerlink" title="Web(VUE)端实现"></a>Web(VUE)端实现</h4>
      <ul>
<li>安装<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">npm install xterm@3.1.0 --save  # 指定版本安装，最新版的xterm文件的改动很大，使用下面的方法会报错</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>导包<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">import 'xterm/dist/xterm.css'</span><br><span class="line">import {Terminal} from 'xterm'</span><br><span class="line">import * as attach from 'xterm/lib/addons/attach/attach' // 安装插件时，可以使用attach去添加</span><br><span class="line">Terminal.applyAddon(attach) // 添加插件</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在页面中渲染<figure class="highlight html"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"terminal"</span> <span class="attr">style</span>=<span class="string">"width: 500px;height:300px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>数据操作<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">mounted() {</span><br><span class="line">		    // 获取到了div标签</span><br><span class="line">            let terminalContainer = document.getElementById('terminal')</span><br><span class="line">            // 初始化黑窗口对象</span><br><span class="line">            this.term = new Terminal(this.terminal)</span><br><span class="line">            // 打开这个对象</span><br><span class="line">            this.term.open(terminalContainer)</span><br><span class="line">            // this.term.write("$ ")</span><br><span class="line">            // this.term.fit()</span><br><span class="line">            // open websocket</span><br><span class="line">        </span><br><span class="line">            this.terminalSocket = new WebSocket('ws://127.0.0.1:8000/webssh/')</span><br><span class="line">            this.terminalSocket.onopen = function () { // 连接成功触发该方法</span><br><span class="line">              // this.term_isconnect = true</span><br><span class="line">              console.log('websocket is Connected...')</span><br><span class="line">            }</span><br><span class="line">            this.terminalSocket.onclose = function () { // 连接关闭适触发的方法</span><br><span class="line">              console.log('websocket is Closed...')</span><br><span class="line">            }</span><br><span class="line">            this.terminalSocket.onerror = function () { // 连接出错触发的方法</span><br><span class="line">              console.log('damn Websocket is broken!')</span><br><span class="line">            }</span><br><span class="line">            this.term.attach(this.terminalSocket)</span><br><span class="line">            // 绑定xterm到ws流中</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>web端完整代码<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="terminal" style="width: 500px;height:300px;"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import 'xterm/dist/xterm.css';</span><br><span class="line">import {Terminal} from 'xterm';</span><br><span class="line">import * as fit from 'xterm/lib/addons/fit/fit';</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(fit);</span><br><span class="line">export default {</span><br><span class="line">  name: 'Webshell',</span><br><span class="line">  data() {</span><br><span class="line">    return {</span><br><span class="line"></span><br><span class="line">      term: null,</span><br><span class="line">      terminalSocket: null,</span><br><span class="line">      order: ''</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  methods: {},</span><br><span class="line">  mounted () {</span><br><span class="line">       // 获取到了div标签</span><br><span class="line">       let terminalContainer = document.getElementById('terminal')</span><br><span class="line">       // 初始化黑窗口对象</span><br><span class="line">       this.term = new Terminal(this.terminal)</span><br><span class="line">       // 打开这个对象</span><br><span class="line">       this.term.open(terminalContainer)</span><br><span class="line">       // open websocket</span><br><span class="line">   </span><br><span class="line">       this.terminalSocket = new WebSocket('ws://127.0.0.1:8000/webssh/')</span><br><span class="line">       this.terminalSocket.onopen = function () { // 连接成功触发该方法</span><br><span class="line">         // this.term_isconnect = true</span><br><span class="line">         console.log('websocket is Connected...')</span><br><span class="line">       }</span><br><span class="line">       this.terminalSocket.onclose = function () { // 连接关闭适触发的方法</span><br><span class="line">         console.log('websocket is Closed...')</span><br><span class="line">       }</span><br><span class="line">       this.terminalSocket.onerror = function () { // 连接出错触发的方法</span><br><span class="line">         console.log('damn Websocket is broken!')</span><br><span class="line">       }</span><br><span class="line">       this.term.attach(this.terminalSocket)</span><br><span class="line">       // 绑定xterm到ws流中</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="服务器端-Django-实现-使用paramiko与服务器建立交互">
          <a href="#服务器端-Django-实现-使用paramiko与服务器建立交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#服务器端-Django-实现-使用paramiko与服务器建立交互" class="headerlink" title="服务器端(Django)实现         使用paramiko与服务器建立交互"></a>服务器端(Django)实现         使用paramiko与服务器建立交互</h4>
        ssh是一个协议，OpenSSH是其中一个开源实现，paramiko是Python的一个库，实现了SSHv2协议(底层使用cryptography)。<br>  有了Paramiko以后，我们就可以在Python代码中直接使用SSH协议对远程服务器执行操作，而不是通过ssh命令对远程服务器进行操作</li>
<li>安装<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">pip install paramiko</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>利用paramiko进行ssh远程登录<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_ssh</span>(<span class="params">host=<span class="string">"********"</span>, username=<span class="string">"***"</span>, password=<span class="string">"****"</span>, port=<span class="number">22</span></span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :host 主机地址</span></span><br><span class="line"><span class="string">    :username 用户名，一般是root</span></span><br><span class="line"><span class="string">    :password 密码</span></span><br><span class="line"><span class="string">    :port ssh协议的端口,22</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 初始化一个ssh对象</span></span><br><span class="line">    sh = paramiko.SSHClient()</span><br><span class="line">    <span class="comment"># 设置对象连接密钥规则</span></span><br><span class="line">    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    <span class="comment"># 连接</span></span><br><span class="line">    sh.connect(host, username=username, password=password, port=port)</span><br><span class="line">    <span class="comment"># 生成shell对象</span></span><br><span class="line">    channle = sh.invoke_shell(term=<span class="string">'xterm'</span>)</span><br><span class="line">    <span class="keyword">return</span> channle</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>编写子线程方法，专注接收web端发送的命令<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_ssh_msg</span>(<span class="params">channle, ws</span>):</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        只管接收</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 判断shell连接对象是否没有退出</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> channle.exit_status_ready():</span><br><span class="line">        <span class="comment"># 接收过程可能会因为没有任何返回而报错</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buf = channle.recv(<span class="number">1024</span>)  <span class="comment"># 接收命令的执行结果</span></span><br><span class="line">            ws.send(buf)  <span class="comment"># 向Websocket通道返回</span></span><br><span class="line">        <span class="comment"># 接收不到会报错，但是报错没关系，继续重新尝试接受</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>结合websocket实现实时操作<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webssh</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">"来人了"</span>)</span><br><span class="line">    <span class="keyword">if</span> request.is_websocket:</span><br><span class="line">        <span class="comment"># 1. 获取到连接对象</span></span><br><span class="line">        ws = request.websocket</span><br><span class="line">        <span class="comment"># 2. 初始化linux连接</span></span><br><span class="line">        channel = make_ssh()</span><br><span class="line">        <span class="comment"># 3. 初始化linux数据接收线程，并开启</span></span><br><span class="line">        recv_thread = Thread(target=recv_ssh_msg, args=(channel, ws))</span><br><span class="line">        recv_thread.start()</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:  <span class="comment"># 主线程: 只管发送</span></span><br><span class="line">            <span class="comment"># 2. 阻塞ws接收发来的数据</span></span><br><span class="line">            cmd = ws.wait()</span><br><span class="line">            <span class="comment"># cmd = ws.recv()</span></span><br><span class="line">            <span class="keyword">if</span> cmd:</span><br><span class="line">                channel.send(cmd)  <span class="comment"># 发送到linux 去执行</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果连接断开，那么cmd将会发一个空包</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        recv_thread.join()  <span class="comment"># 回收子线程</span></span><br><span class="line">        ws.close()  <span class="comment"># 关闭ws连接</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>这样一个webShell就完成了
        <h3 id="OK-本文到此结束">
          <a href="#OK-本文到此结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-本文到此结束" class="headerlink" title="OK 本文到此结束"></a>OK 本文到此结束</h3>
      django-git地址：<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/celery-demo.git">https://gitee.com/before-l/celery-demo.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>视频直播</title>
    <url>/id_11/</url>
    <content><![CDATA[<blockquote>
<p>  直播：流式传输协议，传输非常短的一小截视频</p>
</blockquote>
<ul>
<li>主播直播 <strong>推流</strong><ul>
<li>OBS </li>
</ul>
</li>
<li>观看直播 <strong>拉流</strong><ul>
<li>  浏览器：video标签</li>
<li>  客户端工具：vlc播放器</li>
</ul>
</li>
<li>  协议：rtmp协议</li>
</ul>
<a id="more"></a>

        <h3 id="介绍">
          <a href="#介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>
      <p>视频直播我们需要两个软件，一个用来直播，一个用来看直播<br><strong>直播</strong><br><img src="/id_11/01.png" alt="直播"><br><strong>看直播</strong><br><img src="/id_11/02.png" alt="看直播"></p>

        <h3 id="概念">
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h3>
      
        <h4 id="推流">
          <a href="#推流" class="heading-link"><i class="fas fa-link"></i></a><a href="#推流" class="headerlink" title="推流"></a>推流</h4>
      <p>推流：指的是把采集阶段封包好的内容传输到服务器的过程。<br><img src="/id_11/01.jpg" alt="推流"></p>

        <h4 id="拉流">
          <a href="#拉流" class="heading-link"><i class="fas fa-link"></i></a><a href="#拉流" class="headerlink" title="拉流"></a>拉流</h4>
      <p>拉流：指服务器已有直播内容，用指定地址进行拉取的过程<br><img src="/id_11/02.jpg" alt="拉流"></p>

        <h3 id="协议">
          <a href="#协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#协议" class="headerlink" title="协议"></a>协议</h3>
      <p>主流的推送协议和优缺点</p>

        <h4 id="RTMP">
          <a href="#RTMP" class="heading-link"><i class="fas fa-link"></i></a><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h4>
      <p>RTMP是Real Time Messaging Protocol（实时消息传输协议）的缩写，是Adobe公司为Flash/AIR平台和服务器之间音、视频及数据传输开发的实时消息传送协议。RTMP协议基于TCP，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。<br>RTMP协议中，视频必须是H264编码，音频必须是AAC或MP3编码，且多以flv格式封包。RTMP是目前最主流的流媒体传输协议，对CDN支持良好，实现难度较低，是大多数的直播平台的选择。<br>不过RTMP有着一个最大的不足——不支持浏览器，且Adobe已不再更新。因此直播服务要支持浏览器的话，需要另外的推送协议支持。</p>

        <h4 id="HLS">
          <a href="#HLS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h4>
      <p>Http Live Streaming是由Apple公司定义的基于HTTP的流媒体实时传输协议。它的原理是将整个流分为多个小的文件来下载，每次只下载若干个。服务器端会将最新的直播数据生成新的小文件，客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。基本上，HLS是以点播的技术实现了直播的体验。因为每个小文件的时长很短，客户端可以很快地切换码率，以适应不同带宽条件下的播放。<br>分段推送的技术特点，决定了HLS的延迟一般会高于普通的流媒体直播协议。<br>传输内容包括两部分：一是M3U8描述文件，二是TS媒体文件。TS媒体文件中的视频必须是H264编码，音频必须是AAC或MP3编码。<br>由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短。</p>

        <h4 id="WebRTC">
          <a href="#WebRTC" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h4>
      <p>WebRTC（Web Real-Time Communication），即“源自网页即时通信”。WebRTC是一个支持浏览器进行实时语音、视频对话的开源协议。WebRTC的支持者甚多，Google、Mozilla、Opera推动其成为W3C推荐标准。<br>WebRTC支持目前的主流浏览器，并且基于SRTP和UDP，即便在网络信号一般的情况下也具备较好的稳定性。<br>此外，WebRTC可以实现点对点通信，通信双方延时低，此外，WebRTC可以实现点对点通信，通信双方延时低，是实现“连麦”功能比较好的选择。</p>

        <h3 id="利用云主机搭建直播服务器">
          <a href="#利用云主机搭建直播服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用云主机搭建直播服务器" class="headerlink" title="利用云主机搭建直播服务器"></a>利用云主机搭建直播服务器</h3>
      
        <h4 id="在云主机上环境部署">
          <a href="#在云主机上环境部署" class="heading-link"><i class="fas fa-link"></i></a><a href="#在云主机上环境部署" class="headerlink" title="在云主机上环境部署"></a>在云主机上环境部署</h4>
      <ul>
<li>  创建保存软件目录</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">mkdir /usr/local/nginx-flv</span><br><span class="line"># 创建了一个安装目录</span><br><span class="line">mkdir /home/flv-tools</span><br><span class="line"># 存储所需软件</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li>下载nginx<ul>
<li>什么是nginx，高性能多路复用服务器，让你支持同时响应多个客户连接<ul>
<li>  多线程、多进程开发模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li>  下载直播模块<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/winshining/nginx-http-flv-module</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  解压下载好的nginx<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz nginx-1.18.0/</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  解压下载好的直播模块<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">unzip nginx-http-flv-module.zip </span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  进入解压好的nginx下目录，并进行安装前的配置<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">cd nginx-1.18.0</span><br><span class="line">./configure --prefix=/usr/local/nginx-flv --add-module=/home/flv-tools/nginx-http-flv-module-master</span><br><span class="line"># --prefix: 配置安装路径</span><br><span class="line">#--add-module: 添加安装插件</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  编译及安装<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">make </span><br><span class="line">make install </span><br><span class="line">------------</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="配置文件修改">
          <a href="#配置文件修改" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h4>
      <figure class="highlight shell"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">rtmp_auto_push on;</span><br><span class="line">rtmp_auto_push_reconnect 1s;</span><br><span class="line">rtmp_socket_dir /tmp;</span><br><span class="line"></span><br><span class="line">rtmp{</span><br><span class="line">	out_queue 4096;</span><br><span class="line">	out_cork 8;</span><br><span class="line">	max_streams 128;</span><br><span class="line">	timeout 15s;</span><br><span class="line">	drop_idle_publisher 15s;</span><br><span class="line">	log_interval 5s;</span><br><span class="line">	log_size 1m;</span><br><span class="line">	server {</span><br><span class="line">		listen 1935; # 推流端口</span><br><span class="line">		server_name zege;</span><br><span class="line">		</span><br><span class="line">		application live {	# 配置推流地址</span><br><span class="line">			live on; # 打开推流</span><br><span class="line"><span class="meta">			#</span><span class="bash"> gop_cache on;</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> rtmp://123.123.123.123:1935/live/<span class="built_in">test</span></span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  配置文件http拉流部分<figure class="highlight shell"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">http {</span><br><span class="line">	include       mime.types;</span><br><span class="line">	default_type  application/octet-stream;</span><br><span class="line">	sendfile        on;</span><br><span class="line">	keepalive_timeout  65;</span><br><span class="line">	server {</span><br><span class="line">		listen       8080; # 拉流通过8080去拉流</span><br><span class="line"><span class="meta">		#</span><span class="bash"> http://123.123.123.123:8080/live/?port=1935&amp;stream=<span class="built_in">test</span></span></span><br><span class="line">		server_name  localhost;</span><br><span class="line">		location /live {</span><br><span class="line">			flv_live on;</span><br><span class="line">			chunked_transfer_encoding  on;</span><br><span class="line">			add_header 'Access-Control-Allow-Origin' '*';</span><br><span class="line">			add_header 'Access-Control-Allow-Credentials' 'true';</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  关闭旧有服务<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">/usr/local/nginx-rtmp/sbin/nginx -s stop</span><br><span class="line">/usr/local/nginx-rtmp/sbin/nginx -s reload</span><br><span class="line"># 重启</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  开启新服务<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">/usr/local/nginx-flv/sbin/nginx -c /usr/local/nginx-flv/conf/nginx.conf</span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>   记得打开阿里云的防火墙8080</p>
</blockquote>

        <h3 id="OBS设置推流地址">
          <a href="#OBS设置推流地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#OBS设置推流地址" class="headerlink" title="OBS设置推流地址"></a>OBS设置推流地址</h3>
      </li>
<li>  推流地址<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">rtmp://云主机IP及端口/live/自定义密钥</span><br></pre></td></tr></tbody></table></div></figure>
<img src="/id_11/03.png" alt="推流地址"></li>
<li>  拉流地址<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">http://云主机IP及端口/live?port=端口&amp;app=live&amp;stream=密钥</span><br></pre></td></tr></tbody></table></div></figure>
<img src="/id_11/04.png" alt="拉流地址">
        <h3 id="Vue实现拉流">
          <a href="#Vue实现拉流" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vue实现拉流" class="headerlink" title="Vue实现拉流"></a>Vue实现拉流</h3>
      </li>
<li>  安装<strong>flv.js</strong>开源工具，进行拉流，哔哩哔哩开源的拉流js<blockquote>
<p>  video.js 对rtmp拉流</p>
</blockquote>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">npm install flv.js --save</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  导包<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> flv <span class="keyword">from</span> <span class="string">'flv.js'</span>;</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  构建页面标签，播放标签<figure class="highlight html"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"videoElement"</span> <span class="attr">controls</span> <span class="attr">muted</span>&gt;</span></span><br><span class="line">  	Your browser is too old which doesn't support HTML5 video.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  进行初始化<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">var</span> videoElement = <span class="built_in">document</span>.getElementById(<span class="string">'videoElement'</span>);</span><br><span class="line">    <span class="keyword">var</span> flvPlayer = flv.createPlayer({</span><br><span class="line">      type: <span class="string">'flv'</span>,</span><br><span class="line">      enableWorker: <span class="literal">true</span>,     <span class="comment">//浏览器端开启flv.js的worker,多进程运行flv.js</span></span><br><span class="line">      isLive: <span class="literal">true</span>,           <span class="comment">//直播模式</span></span><br><span class="line">      hasAudio: <span class="literal">false</span>,        <span class="comment">//关闭音频</span></span><br><span class="line">      hasVideo: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// cors: true,</span></span><br><span class="line">      stashInitialSize: <span class="number">128</span>,</span><br><span class="line">      enableStashBuffer: <span class="literal">false</span>, <span class="comment">//播放flv时，设置是否启用播放缓存，只在直播起作用。</span></span><br><span class="line">      url: <span class="string">'http://云主机IP及端口/live?port=端口&amp;app=live&amp;stream=密钥'</span></span><br><span class="line">    })</span><br><span class="line">    flvPlayer.attachMediaElement(videoElement);</span><br><span class="line">    flvPlayer.load();</span><br><span class="line">    flvPlayer.play();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="OK-这样一个直播就做好了">
          <a href="#OK-这样一个直播就做好了" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-这样一个直播就做好了" class="headerlink" title="OK,这样一个直播就做好了"></a>OK,这样一个直播就做好了</h3>
      </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>无限级递归分类</title>
    <url>/id_12/</url>
    <content><![CDATA[<p>所谓的无限极分类是啥？其实简单点说就是一个人类可以繁衍出多个后代，然后一个后代又可以分另外多个后代这样无限繁衍下去（举例：家族族谱），就好象linux系统你可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样，随后使用tree命令就可以查看文件夹目录层级。<br>那么这种层级结构也成为树结构在日常的开发需求里也是很常见的，比如美多商城系统的商品分类，课程的目录章节，以及以及论坛里的帖子回复等等</p>
<a id="more"></a>

        <h3 id="话不多说，上案例：">
          <a href="#话不多说，上案例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#话不多说，上案例：" class="headerlink" title="话不多说，上案例："></a>话不多说，上案例：</h3>
      
        <h4 id="首先，打开django项目中的models-py，新建一个类别的模型类，这里我们以最简单的parentid的形式来建立">
          <a href="#首先，打开django项目中的models-py，新建一个类别的模型类，这里我们以最简单的parentid的形式来建立" class="heading-link"><i class="fas fa-link"></i></a><a href="#首先，打开django项目中的models-py，新建一个类别的模型类，这里我们以最简单的parentid的形式来建立" class="headerlink" title="首先，打开django项目中的models.py，新建一个类别的模型类，这里我们以最简单的parentid的形式来建立"></a>首先，打开django项目中的models.py，新建一个类别的模型类，这里我们以最简单的parentid的形式来建立</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cate</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 分类名称</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 父级id</span></span><br><span class="line">    pid = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表名</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'cate'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="由于我们的项目基于drf框架，所以要增加一个序列器类">
          <a href="#由于我们的项目基于drf框架，所以要增加一个序列器类" class="heading-link"><i class="fas fa-link"></i></a><a href="#由于我们的项目基于drf框架，所以要增加一个序列器类" class="headerlink" title="由于我们的项目基于drf框架，所以要增加一个序列器类"></a>由于我们的项目基于drf框架，所以要增加一个序列器类</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> WXJapp.models <span class="keyword">import</span> Cate</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CateSer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cate</span><br><span class="line">        fields = <span class="string">"__all__"</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="由于django序列化出来的类不具备层级结构，所以我们提前写好一个用来递归的方法：">
          <a href="#由于django序列化出来的类不具备层级结构，所以我们提前写好一个用来递归的方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#由于django序列化出来的类不具备层级结构，所以我们提前写好一个用来递归的方法：" class="headerlink" title="由于django序列化出来的类不具备层级结构，所以我们提前写好一个用来递归的方法："></a>由于django序列化出来的类不具备层级结构，所以我们提前写好一个用来递归的方法：</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xTree</span>(<span class="params">datas</span>):</span></span><br><span class="line">    lists = []</span><br><span class="line">    tree = {}</span><br><span class="line">    parent_id = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> datas:</span><br><span class="line">        item = i</span><br><span class="line">        print(item)</span><br><span class="line">        tree[item[<span class="string">'id'</span>]] = item</span><br><span class="line">    root = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> datas:</span><br><span class="line">        obj = i</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj[<span class="string">'pid'</span>]:</span><br><span class="line">            root = tree[obj[<span class="string">'id'</span>]]</span><br><span class="line">            lists.append(root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent_id = obj[<span class="string">'pid'</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'childlist'</span> <span class="keyword">not</span> <span class="keyword">in</span> tree[parent_id]:</span><br><span class="line">                tree[parent_id][<span class="string">'childlist'</span>] = []</span><br><span class="line">            tree[parent_id][<span class="string">'childlist'</span>].append(tree[obj[<span class="string">'id'</span>]])</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="此时我们写一个视图接口，从数据库中读取数据就可以了">
          <a href="#此时我们写一个视图接口，从数据库中读取数据就可以了" class="heading-link"><i class="fas fa-link"></i></a><a href="#此时我们写一个视图接口，从数据库中读取数据就可以了" class="headerlink" title="此时我们写一个视图接口，从数据库中读取数据就可以了"></a>此时我们写一个视图接口，从数据库中读取数据就可以了</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTree</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="comment"># 获取订单列表</span></span><br><span class="line">        catelist = Cate.objects.<span class="built_in">all</span>()</span><br><span class="line">        <span class="comment"># 序列化</span></span><br><span class="line">        catelist_ser = CateSer(catelist, many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        mylist = xTree(catelist_ser.data)</span><br><span class="line">        print(mylist)</span><br><span class="line">        <span class="keyword">return</span> Response(mylist)</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="最后，再配个路由">
          <a href="#最后，再配个路由" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后，再配个路由" class="headerlink" title="最后，再配个路由"></a>最后，再配个路由</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> WXJapp.views <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'mytree/'</span>, MyTree.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="这样我们的后端就写好了">
          <a href="#这样我们的后端就写好了" class="heading-link"><i class="fas fa-link"></i></a><a href="#这样我们的后端就写好了" class="headerlink" title="这样我们的后端就写好了"></a>这样我们的后端就写好了</h3>
      
        <h4 id="向数据库中添加测试数据">
          <a href="#向数据库中添加测试数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#向数据库中添加测试数据" class="headerlink" title="向数据库中添加测试数据"></a>向数据库中添加测试数据</h4>
      <p><img src="/id_12/01.png" alt="测试数据"></p>

        <h4 id="Postman测试后端接口">
          <a href="#Postman测试后端接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Postman测试后端接口" class="headerlink" title="Postman测试后端接口"></a>Postman测试后端接口</h4>
      <p><img src="/id_12/02.png" alt="测试接口"></p>

        <h3 id="现在我们开始写前端，">
          <a href="#现在我们开始写前端，" class="heading-link"><i class="fas fa-link"></i></a><a href="#现在我们开始写前端，" class="headerlink" title="现在我们开始写前端，"></a>现在我们开始写前端，</h3>
      
        <h4 id="打开vue项目，封装一个WXJcate-vue递归组件">
          <a href="#打开vue项目，封装一个WXJcate-vue递归组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#打开vue项目，封装一个WXJcate-vue递归组件" class="headerlink" title="打开vue项目，封装一个WXJcate.vue递归组件"></a>打开vue项目，封装一个WXJcate.vue递归组件</h4>
      <p>所谓递归组件: 就是组件可以在它们自己的模板中调用自身，不过它们只能通过 name 选项来做这件事，例如给组件设置属性 name: ‘WJXcate’，然后在模板中就可以使用 WXJcate 调用自己进行递归调用了</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;div :class="[data.id==0 ? 'root': '', 'wxjcate']"&gt;{{ data.name }}&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;ul v-if="data.childlist &amp;&amp; data.childlist.length&gt;0"&gt;</span><br><span class="line">        &lt;WXJcate v-for="child in data.childlist" :key="child.id" :data="child"/&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: 'WXJcate', // 递归组件需要设置 name 属性，才能在模板中调用自己</span><br><span class="line">  props:['data'],</span><br><span class="line">};</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style &gt;</span><br><span class="line">.wxjcate {</span><br><span class="line">  padding-left: 8px;</span><br><span class="line">  border-left: 1px solid gray;</span><br><span class="line">}</span><br><span class="line">ul {</span><br><span class="line">  padding-left: 20px;</span><br><span class="line">  list-style: none;</span><br><span class="line">}</span><br><span class="line">.root { display: none; }</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="然后就可以在其他页面中调用这个递归组件">
          <a href="#然后就可以在其他页面中调用这个递归组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#然后就可以在其他页面中调用这个递归组件" class="headerlink" title="然后就可以在其他页面中调用这个递归组件"></a>然后就可以在其他页面中调用这个递归组件</h4>
      <p>在WXJ_Index调用递归组件并请求后端的数据</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;WXJcate :data="data" /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import WXJcate from './WXJcate.vue';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  data () {</span><br><span class="line">    return {</span><br><span class="line">      data:{},</span><br><span class="line">      online: 0</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  components: {</span><br><span class="line">    WXJcate</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  //钩子方法</span><br><span class="line">  mounted:function(){</span><br><span class="line"></span><br><span class="line">    this.get_token();</span><br><span class="line">  },</span><br><span class="line">  //绑定事件</span><br><span class="line">  methods:{</span><br><span class="line">    get_token(){</span><br><span class="line">      this.$axios.get('mytree/').then((result) =&gt;{</span><br><span class="line">        // console.log(result);</span><br><span class="line">        var mytree = {'id':0,name:'123'};</span><br><span class="line">        mytree['childlist'] = result.data;</span><br><span class="line">        this.data = mytree;</span><br><span class="line">      });</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">.on {</span><br><span class="line">  background: #cdcbff;</span><br><span class="line">}</span><br><span class="line">.off {</span><br><span class="line">  background: #fefdff;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="这样我们的Web端就写好了">
          <a href="#这样我们的Web端就写好了" class="heading-link"><i class="fas fa-link"></i></a><a href="#这样我们的Web端就写好了" class="headerlink" title="这样我们的Web端就写好了"></a>这样我们的Web端就写好了</h3>
      
        <h4 id="最后我们来看一下页面效果">
          <a href="#最后我们来看一下页面效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后我们来看一下页面效果" class="headerlink" title="最后我们来看一下页面效果"></a>最后我们来看一下页面效果</h4>
      <p><img src="/id_12/03.png" alt="最终效果"></p>
<p>django-git地址：<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/celery-demo.git">https://gitee.com/before-l/celery-demo.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>vue-git地址：<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/annual-leave-vue.git">https://gitee.com/before-l/annual-leave-vue.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>微博三方登录</title>
    <url>/id_13/</url>
    <content><![CDATA[<p>三方登录流程：</p>
<pre><code>   理解第三方登录的流程

   用户向后端发起请求，我要用微博进行登录

   我们的前端凑一个url让用户跳转到第三方应用的url(微博的登录页面)

   用户在该界面点击输入用户名密码之后，点击授权。

   微博有个回调url指向我们的后端。

   我们的后端就可以获取到用户的基本信息等。</code></pre>
<a id="more"></a>

<p>微博开放平台网址：<span class="exturl"><a class="exturl__link" href="https://open.weibo.com/?sudaref=www.baidu.com">https://open.weibo.com/?sudaref=www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>微博三方登录的指导思想：OAuth2.0授权认证</p>
<p>步骤：</p>

        <h4 id="1-创建应用">
          <a href="#1-创建应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建应用" class="headerlink" title="1.创建应用"></a>1.创建应用</h4>
      <p><img src="/id_13/01.png" alt="创建应用"></p>

        <h4 id="2-设置回调地址">
          <a href="#2-设置回调地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-设置回调地址" class="headerlink" title="2.设置回调地址"></a>2.设置回调地址</h4>
      <p><img src="/id_13/02.png" alt="设置回调地址"></p>

        <h4 id="3-请求用户授权token">
          <a href="#3-请求用户授权token" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-请求用户授权token" class="headerlink" title="3. 请求用户授权token"></a>3. 请求用户授权token</h4>
      <p><img src="/id_13/03.png" alt="请求用户授权Token"><br><img src="/id_13/04.png" alt="请求用户授权Token"><br><img src="/id_13/05.png" alt="请求用户授权Token"></p>
<ul>
<li>在前端写一个超链接用来向微博发送请求<figure class="highlight html"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://api.weibo.com/oauth2/authorize?client_id=xxxxxxxx&amp;redirect_uri=xxxxxxxx"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../assets/240.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="4-获取授权过的Access-Token">
          <a href="#4-获取授权过的Access-Token" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-获取授权过的Access-Token" class="headerlink" title="4.获取授权过的Access Token"></a>4.获取授权过的Access Token</h4>
      <img src="/id_13/06.png" alt="获取授权过的Acccess Token"><br><img src="/id_13/07.png" alt="获取授权过的Acccess Token"></li>
</ul>

        <h4 id="5-在后端写一个接口用来进行网络请求-使用requests三方模块">
          <a href="#5-在后端写一个接口用来进行网络请求-使用requests三方模块" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-在后端写一个接口用来进行网络请求-使用requests三方模块" class="headerlink" title="5.在后端写一个接口用来进行网络请求(使用requests三方模块)"></a>5.在后端写一个接口用来进行网络请求(使用requests三方模块)</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiboView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        code = request.GET.get(<span class="string">"code"</span>)</span><br><span class="line">        <span class="comment"># 通过python进行网络请求 requests</span></span><br><span class="line">        r = requests.post(<span class="string">"https://api.weibo.com/oauth2/access_token"</span>, {</span><br><span class="line">            <span class="comment"># App Key</span></span><br><span class="line">            <span class="string">"client_id"</span>: xxxx,</span><br><span class="line">            <span class="comment"># 密钥  App Secret</span></span><br><span class="line">            <span class="string">"client_secret"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="comment"># 请求的类型</span></span><br><span class="line">            <span class="string">"grant_type"</span>: <span class="string">"authorization_code"</span>,</span><br><span class="line">            <span class="comment"># 调用authorize获得的code值。</span></span><br><span class="line">            <span class="string">"code"</span>: code,</span><br><span class="line">            <span class="comment"># 回调地址</span></span><br><span class="line">            <span class="string">"redirect_uri"</span>: <span class="string">"http://127.0.0.1:8000/weibo/"</span></span><br><span class="line">        })</span><br><span class="line">        access_token = r.json()[<span class="string">'access_token'</span>]</span><br><span class="line">        uid = r.json()[<span class="string">'uid'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先判断微博账号是否登录过，没有登录过则把账号添加到第三方表中，登陆过则返回登录信息</span></span><br><span class="line">        open_user = OpenUser.objects.<span class="built_in">filter</span>(uid=uid).first()</span><br><span class="line">        <span class="keyword">if</span> open_user:</span><br><span class="line">            <span class="comment"># 已经登录过了</span></span><br><span class="line">            user = open_user.user</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            user = User.objects.create(username=uid, password=uid)</span><br><span class="line">            <span class="comment"># 没有登录</span></span><br><span class="line">            OpenUser.objects.create(uid=uid, cate=<span class="string">"微博"</span>, user=user)</span><br><span class="line">        <span class="comment"># 生成令牌</span></span><br><span class="line">        token = jwt.encode({<span class="string">"uid"</span>:user.<span class="built_in">id</span>},<span class="string">'123'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 跳转到前端首页</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"登录成功,点击跳转&lt;a href='http://127.0.0.1:8080/#/index?token=%s&amp;username=%s'&gt;跳转&lt;/a&gt;"</span>%(token.decode(),uid))</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="6-OK-这样一个微博三方登录就做好啦">
          <a href="#6-OK-这样一个微博三方登录就做好啦" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-OK-这样一个微博三方登录就做好啦" class="headerlink" title="6.OK 这样一个微博三方登录就做好啦"></a>6.OK 这样一个微博三方登录就做好啦</h4>
      
        <h5 id="vue-git地址：https-gitee-com-before-l-annual-leave-vue-git">
          <a href="#vue-git地址：https-gitee-com-before-l-annual-leave-vue-git" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue-git地址：https-gitee-com-before-l-annual-leave-vue-git" class="headerlink" title="vue-git地址：https://gitee.com/before-l/annual-leave-vue.git"></a>vue-git地址：<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/annual-leave-vue.git">https://gitee.com/before-l/annual-leave-vue.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h5>
      
        <h5 id="django-git地址-https-gitee-com-before-l-annual-leave-git">
          <a href="#django-git地址-https-gitee-com-before-l-annual-leave-git" class="heading-link"><i class="fas fa-link"></i></a><a href="#django-git地址-https-gitee-com-before-l-annual-leave-git" class="headerlink" title="django-git地址:https://gitee.com/before-l/annual-leave.git"></a>django-git地址:<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/annual-leave.git">https://gitee.com/before-l/annual-leave.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h5>
      ]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>三方</tag>
      </tags>
  </entry>
  <entry>
    <title>三方支付</title>
    <url>/id_14/</url>
    <content><![CDATA[<p>三方支付流程：</p>
<pre><code>首先进入支付宝平台，点击开发中心-》研发服务

获得沙箱的appid以及商户公钥和支付宝公钥

然后利用秘钥生成软件生成私钥和公钥

建立keys文件夹，  将私钥和公钥文件放入keys

加入头部和尾部代码

最后用支付宝公钥替换公钥文件</code></pre>
<a id="more"></a>

<p>支付宝开放平台：<span class="exturl"><a class="exturl__link" href="https://open.alipay.com/platform/home.htm">https://open.alipay.com/platform/home.htm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="1-支付宝沙箱商家应用RSA2密钥生成">
          <a href="#1-支付宝沙箱商家应用RSA2密钥生成" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-支付宝沙箱商家应用RSA2密钥生成" class="headerlink" title="1.支付宝沙箱商家应用RSA2密钥生成"></a>1.支付宝沙箱商家应用RSA2密钥生成</h4>
      <p>可以使用支付宝开发助手来实现密钥的生成<br>具体步骤查看官方网站：<span class="exturl"><a class="exturl__link" href="https://opendocs.alipay.com/open/291/105971">https://opendocs.alipay.com/open/291/105971</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>同时配置到沙箱</p>

        <h4 id="2-安装支付宝SDK模块">
          <a href="#2-安装支付宝SDK模块" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-安装支付宝SDK模块" class="headerlink" title="2.安装支付宝SDK模块"></a>2.安装支付宝SDK模块</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 支付宝的sdk已经集成为一个python模块，只需要安装模块进行开发。</span></span><br><span class="line">pip install pycryptodome</span><br><span class="line"></span><br><span class="line">pip install python-alipay-sdk --upgrade</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="3-安装完成-测试支付功能">
          <a href="#3-安装完成-测试支付功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-安装完成-测试支付功能" class="headerlink" title="3.安装完成 测试支付功能"></a>3.安装完成 测试支付功能</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> alipay <span class="keyword">import</span> AliPay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公钥</span></span><br><span class="line">alipay_public_key_string = <span class="string">"""-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">此处填写公钥</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 私钥</span></span><br><span class="line">app_private_key_string = <span class="string">"""-----BEGIN RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="string">此处填写私钥</span></span><br><span class="line"><span class="string">-----END RSA PRIVATE KEY-----"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化支付请求</span></span><br><span class="line">alipay = AliPay(</span><br><span class="line">    appid = <span class="string">"xxxxxxxxx"</span>,     <span class="comment"># APPID</span></span><br><span class="line">    app_notify_url = <span class="literal">None</span>,</span><br><span class="line">    app_private_key_string = app_private_key_string,</span><br><span class="line">    alipay_public_key_string = alipay_public_key_string,</span><br><span class="line">    sign_type = <span class="string">"RSA2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发起支付请求</span></span><br><span class="line">order_string = alipay.api_alipay_trade_page_pay(</span><br><span class="line">    out_trade_no = <span class="string">'10001'</span>, <span class="comment">#订单号</span></span><br><span class="line">    total_amount= <span class="built_in">str</span>(<span class="number">10000</span>), <span class="comment">#支付金额</span></span><br><span class="line">    subject = <span class="string">'水果干果'</span>,</span><br><span class="line">    return_url=<span class="string">"http://127.0.0.1:8000/buyer/pr/"</span>,</span><br><span class="line">    <span class="comment"># 支付宝回调地址 </span></span><br><span class="line">    notify_url=<span class="string">"http://127.0.0.1:8000/buyer/pr/"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(<span class="string">"https://openapi.alipaydev.com/gateway.do?"</span> + order_string)</span><br></pre></td></tr></tbody></table></div></figure>


        <h4 id="4-最后附上流程图：">
          <a href="#4-最后附上流程图：" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-最后附上流程图：" class="headerlink" title="4.最后附上流程图："></a>4.最后附上流程图：</h4>
      <p><img src="/id_14/01.png" alt="三方支付流程图"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>三方</tag>
      </tags>
  </entry>
  <entry>
    <title>celery异步框架</title>
    <url>/id_15/</url>
    <content><![CDATA[<p>Celery是一个简单、灵活且可靠的，处理大量消息的<strong>分布式系统</strong>。它专注于实时处理的异步任务队列，同时也支持任务调度。<br>Celery官方文档中文版：<span class="exturl"><a class="exturl__link" href="http://docs.jinkan.org/docs/celery/">http://docs.jinkan.org/docs/celery/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h4 id="1-Celery简介">
          <a href="#1-Celery简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Celery简介" class="headerlink" title="1.Celery简介"></a>1.Celery简介</h4>
      <p>我们通常使用Celery来实现异步任务（async task）和定时任务（Celery Beat）比如发邮件<br>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成<br>附上架构图：<img src="/id_15/01.png" alt="Celery架构图"></p>
<p>由此架构图得知Celery主要包含以下几个<strong>模块</strong>：</p>
<ul>
<li><p>任务模块 Task<br>包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往任务队列，而定时任务由 Celery Beat 进程周期性地将任务发往任务队列。</p>
</li>
<li><p>消息中间件 Broker<br>Broker，即为任务调度队列，接收任务生产者发来的消息（即任务），将任务存入队列。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</p>
</li>
<li><p>任务执行单元 Worker<br>Worker 是执行任务的处理单元，它实时监控消息队列，获取队列中调度的任务，并执行它。</p>
</li>
<li><p>任务结果存储 Backend<br>Backend 用于存储任务的执行结果，以供查询。同消息中间件一样，存储也可使用 RabbitMQ, redis 和 MongoDB 等。</p>
</li>
</ul>

        <h6 id="Celery优点">
          <a href="#Celery优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#Celery优点" class="headerlink" title="Celery优点"></a>Celery优点</h6>
      <ul>
<li>简单：celery的 配置和使用还是比较简单的, 非常容易使用和维护和不需要配置文件</li>
<li>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</li>
<li>如果连接丢失或发生故障，worker和client 将自动重试，并且一些代理通过主/主或主/副本复制方式支持HA。</li>
<li>快速：一个单进程的celery每分钟可处理上百万个任务</li>
<li>灵活： 几乎celery的各个组件都可以被扩展及自定制</li>
</ul>

        <h4 id="2-Celery的使用">
          <a href="#2-Celery的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Celery的使用" class="headerlink" title="2.Celery的使用"></a>2.Celery的使用</h4>
      
        <h6 id="创建Django项目，">
          <a href="#创建Django项目，" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建Django项目，" class="headerlink" title="创建Django项目，"></a>创建Django项目，</h6>
      <p>目录如下:<br><img src="/id_15/02.png" alt="Django目录"></p>
<ul>
<li>安装<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"># 安装django-celery-results</span><br><span class="line">pip install django-celery-results</span><br><span class="line"># 安装Redis</span><br><span class="line">pip install redis</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在setting文件中配置<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ····</span><br><span class="line">    <span class="string">'django_celery_results'</span></span><br><span class="line">    ····</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在setting同级目录下创建celery.py文件<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># celery.py文件中</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为celery设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'DjCelery.settings'</span>)</span><br><span class="line"><span class="comment"># 首先你需要一个 Celery 实例，称为 Celery 应用或直接简称应用</span></span><br><span class="line">app = Celery(<span class="string">'DjCelery'</span>)</span><br><span class="line"><span class="comment">#  从单独的配置模块中加载配置，导入celery配置</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>)</span><br><span class="line">app.conf.enable_utc = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line">app.conf.timezone = <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="comment"># 自动搜索任务</span></span><br><span class="line">app.autodiscover_tasks()</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在setting同级目录__init__文件中<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br><span class="line"></span><br><span class="line">__all__ = (<span class="string">'celery_app'</span>,)</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在app中创建tasks.py文件<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> shared_task</span><br><span class="line"></span><br><span class="line"><span class="meta">@shared_task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在views.py文件中调用它<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> tasks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 例如我们希望在用户发出request后异步执行该task, 马上返回response,</span></span><br><span class="line">        <span class="comment"># 从而不阻塞该request, 使用户有一个流畅的访问过程.</span></span><br><span class="line">        <span class="comment"># 那么, 我们可以使用.delay</span></span><br><span class="line">        <span class="comment"># delay是注册为celery异步任务的关键点</span></span><br><span class="line">        res = tasks.add.delay(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 返回执行结果和执行结果ID号</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse({<span class="string">'status'</span>: <span class="string">'successful'</span>, <span class="string">'task_id'</span>: res.task_id})</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>最后使用celery命令启动work<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"># 注意：需要切换目录到执行文件的目录下，否则会报错</span><br><span class="line">cd celery_app</span><br><span class="line">celery -A tasks worker  --loglevel=info</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="3-总结：">
          <a href="#3-总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-总结：" class="headerlink" title="3. 总结："></a>3. 总结：</h4>
      本文简单介绍了 celery 的基本的功能 , 以及celery 能够处理的任务特点,以及可以和 django 结合起来使用. 简单分析了 celery 的工作机制 . 当然 如果想要深入了解 celery,可以 参考 celery的官方文档.</li>
</ul>
<p>django-git地址：<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/celery-demo.git">https://gitee.com/before-l/celery-demo.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>好文：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/u010339879/article/details/97691231">https://blog.csdn.net/u010339879/article/details/97691231</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title>redis发布订阅</title>
    <url>/id_16/</url>
    <content><![CDATA[<p>Redis提供了发布订阅功能，跟消息中间件是类似的，可以用于消息的传输，Redis提供了一组命令可以让开发者实现“发布/订阅”模式 (publish/subscribe) ，该模式同样可以实现进程间的消息传递。<br>它的实现原理是发布/订阅模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道，而发布者可以向指定的 频道发送消息，所有订阅此频道的订阅者都会收到该消息。</p>
<a id="more"></a>

        <h4 id="关系图">
          <a href="#关系图" class="heading-link"><i class="fas fa-link"></i></a><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h4>
      <p><img src="/id_16/01.png" alt="发布订阅"></p>

        <h4 id="redis-消息订阅和发布命令：">
          <a href="#redis-消息订阅和发布命令：" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis-消息订阅和发布命令：" class="headerlink" title="redis 消息订阅和发布命令："></a>redis 消息订阅和发布命令：</h4>
      <ol>
<li>psubscribe pattern [pattern…] ：订阅一个或多个给定模式的 频道</li>
<li>punsubscribe [pattern [pttern…]]：退订所有频道给定模式的频道</li>
<li>pubsub subcommand [argument [argument…]]：查看订阅与发布系统状态</li>
<li>publish channel message：将信息发送到指定的频道</li>
<li>subscribe channel [channel…]：订阅给定的一个或多个频道信息。</li>
<li>unsubscribe [channel [channel…]]：指退订给定的频道。</li>
</ol>

        <h4 id="案例-for-example-：">
          <a href="#案例-for-example-：" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例-for-example-：" class="headerlink" title="案例 for example ："></a>案例 for example ：</h4>
      <p><strong>注意</strong>：需要打开两个小黑窗口哦！</p>
<ol>
<li><p>一次订阅多个频道 c1,c2,c3 (subscribe c1 c2 c3)<br><img src="/id_16/02.png" alt="订阅多个频道"></p>
</li>
<li><p>消息发布，向c2频道发布消息 (publish c2 hello-redis)<br><img src="/id_16/03.png" alt="向指定频道发布消息"></p>
</li>
<li><p>订阅给定模式的频道，通配符* (psubscribe new*)<br><img src="/id_16/04.png" alt="订阅特定模式的频道"></p>
</li>
<li><p>发布消息 (publish new1 redis-hello)<br><img src="/id_16/05.png" alt="发布消息"></p>
</li>
</ol>

        <h4 id="OK-本文到此结束">
          <a href="#OK-本文到此结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-本文到此结束" class="headerlink" title="OK 本文到此结束"></a>OK 本文到此结束</h4>
      ]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis键空间事件</title>
    <url>/id_17/</url>
    <content><![CDATA[<p>Redis的键空间通知(keyspace notifications)功能是自2.8.0版本开始加入的，客户端可以通过订阅/发布(Pub/Sub)机制，接收那些以某种方式改变了Redis数据空间的事件通知。比如：所有改变给定key的命令；所有经过lpush操作的key；所有在0号数据库中过期的key等等。<br>通知是通过Redis的订阅/发布机制发送的，因此，所有支持订阅/发布功能的客户端都可在无需调整的情况下，使用键空间通知功能。</p>
<a id="more"></a>


        <h4 id="启用">
          <a href="#启用" class="heading-link"><i class="fas fa-link"></i></a><a href="#启用" class="headerlink" title="启用"></a>启用</h4>
      <p>因键空间通知功能需要耗费一定的CPU时间，因此默认情况下，该功能是关闭的。<br>可以通过修改配置文件redis.conf，或者通过config set notify-keyspace-events KEA，来启用或关闭该功能。</p>
<p>KEA字符串表示启用了所有可能的事件。要查看每个字符的含义，请参考文档：<span class="exturl"><a class="exturl__link" href="https://redis.io/topics/notifications">https://redis.io/topics/notifications</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>CLI 可以在特殊模式下工作，允许您订阅一个通道以接收消息。</p>

        <h4 id="事件的类型">
          <a href="#事件的类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4>
      <p> 针对改变Redis数据空间的每个操作，键空间通知都会发送两类不同的事件。<br>比如在0号数库中，执行del mykey操作，将会触发两个消息，等价于执行下面两个publish命令：</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey <span class="keyword">del</span></span><br><span class="line">PUBLISH __keyevent@0__:<span class="keyword">del</span> mykey</span><br></pre></td></tr></tbody></table></div></figure>
<p>一个频道发布0号数据库中，所有针对mykey键执行的操作，这类事件，以keyspace为前缀，称为keyspace通知；<br> 另一个频道发布0号数据库中，所有成功执行del操作的键，这类事件，以keyevent为前缀，称为keyevent通知；<br> 在上面的例子中，当执行del  mykey时，会发生：<br> a：keyspace频道的订阅者会收到消息，消息中包含键执行的操作的名字；<br> b：keyevent频道的订阅者会收到消息，消息中包含执行某种操作的键的名字；<br> 可以通过配置，使Redis仅发送某一类我们感兴趣的通知。</p>

        <h4 id="案例-1-for-example-：">
          <a href="#案例-1-for-example-：" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例-1-for-example-：" class="headerlink" title="案例 1 for example ："></a>案例 1 for example ：</h4>
      <ol>
<li>Redis发布所有通知，客户端A订阅所有消息：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;  psubscribe __key*@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>  然后，在客户端B上执行set和del命令：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>此时客户端A的打印就变成了这样： <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyevent@0__:set"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"liu"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"del"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyevent@0__:del"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"liu"</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>可见，针对每一个操作，客户端A都收到了两种消息，分别是keyspace和keyevent消息。</li>
</ol>

        <h4 id="案例-2-for-example-：">
          <a href="#案例-2-for-example-：" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例-2-for-example-：" class="headerlink" title="案例 2 for example ："></a>案例 2 for example ：</h4>
      <ol>
<li>使Redis仅发布keyspace通知，而客户端A订阅所有消息类型：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KA</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; psubscribe __key*@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>然后，在客户端B上执行set和del命令：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>此时客户端A的打印就变成了这样： <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"del"</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>可见，尽管客户端A订阅了所有消息，但是Redis仅发布了keyspace事件。<br>而且，在客户端B上执行了两次del操作，而只有第一个del成功执行了，从而产生了一个事件。</li>
</ol>

        <h4 id="案例-3-for-example-：">
          <a href="#案例-3-for-example-：" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例-3-for-example-：" class="headerlink" title="案例 3 for example ："></a>案例 3 for example ：</h4>
      <ol>
<li>Redis发布所有通知，客户端A仅订阅keyspace消息<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; psubscribe __keyspace@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyspace@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>然后，在客户端B上执行set和del命令：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>此时客户端A的打印就变成了这样： <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyspace@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyspace@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"del"</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>可见，针对每一个操作，客户端A只收到了keyspace消息</li>
</ol>

        <h4 id="案例-4-for-example-：">
          <a href="#案例-4-for-example-：" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例-4-for-example-：" class="headerlink" title="案例 4 for example ："></a>案例 4 for example ：</h4>
      <ol>
<li>Redis仅发布字符串特定类型的通知，客户端A订阅所有类型的消息<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KE$</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; psubscribe __key*@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>在客户端B上，分别执行lpush，set和del命令：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush <span class="built_in">list</span> liu hui ran</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>此时客户端A的打印就变成了这样：<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyevent@0__:set"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"liu"</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>可见，针对字符串，产生了keyspace和keyevent类型的消息，而针对列表的lpush命令并没有产生消息，而且，del命令是非特定类型的命令，也没有产生消息。</li>
</ol>

        <h4 id="OK-本文到此结束">
          <a href="#OK-本文到此结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-本文到此结束" class="headerlink" title="OK,本文到此结束"></a>OK,本文到此结束</h4>
      <p>要查看所有有可能的时间，请参考文档：<span class="exturl"><a class="exturl__link" href="https://redis.io/topics/notifications">https://redis.io/topics/notifications</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>用户注册</title>
    <url>/id_18/</url>
    <content><![CDATA[<h4 id="用户注册功能">
          <a href="#用户注册功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户注册功能" class="headerlink" title="用户注册功能"></a>用户注册功能</h4>
      <p>需求：实现用户注册功能，并将用户注册信息保存到磁盘文件中，用户注册时至少给定：用户名和密码<br>注意：用户名使用了唯一索引，不可重复</p>
<a id="more"></a>
<ul>
<li>相关问题：</li>
</ul>
<p><strong>问</strong>：唯一索引干嘛用的 为什么用？<br><strong>答</strong>：指的是某个字段不能出现重复的值，比如身份证列，手机号。<br>使用唯一索引避免了注册时需要进数据库查询是否有重复的一次IO操作，节省时间，提高效率</p>
<p>OK 上代码</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">register</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        username = request.data.get(<span class="string">"username"</span>)</span><br><span class="line">        password = request.data.get(<span class="string">"password"</span>)</span><br><span class="line">        leave = request.data.get(<span class="string">"leave"</span>)       <span class="comment"># 用户等级</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            UserModel.objects.create(username=username, password=password, leave=leave)</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"添加成功"</span>, <span class="string">"code"</span>: <span class="number">200</span>})</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"该用户已存在"</span>, <span class="string">"code"</span>: <span class="number">400</span>})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>接口测试中的异步调用和异步写入文件</title>
    <url>/id_19/</url>
    <content><![CDATA[<p>异步调用：<br>异步方法必须async 关键字声明<br>所有其他方法，耗时任务都需要加上await关键字，await必须依靠async<br>with用来建立工作流和关闭流对象</p>
<a id="more"></a>

        <h4 id="异步发送100次请求">
          <a href="#异步发送100次请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步发送100次请求" class="headerlink" title="异步发送100次请求"></a>异步发送100次请求</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 异步调用</span></span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url = <span class="string">'http://127.0.0.1:8000/p8/user'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">client</span>):</span></span><br><span class="line">    r = <span class="keyword">await</span> client.get(url)</span><br><span class="line">    print(r.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># 100 次调用</span></span><br><span class="line">        task_list = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            req = request(client)</span><br><span class="line">            task = asyncio.create_task(req)</span><br><span class="line">            task_list.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*task_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="comment"># 结束</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'异步：发送100次请求，耗时：<span class="subst">{end - start}</span>'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="异步写文件">
          <a href="#异步写文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步写文件" class="headerlink" title="异步写文件"></a>异步写文件</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">await</span> f.write(<span class="string">"欢迎来到缅甸北部\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">"10000.txt"</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 列表推导式调用，更快，效率更高 </span></span><br><span class="line">        task = [asyncio.create_task(write(f)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]</span><br><span class="line">        <span class="comment"># 普通列表 相对于列表推导式要慢一点</span></span><br><span class="line">        <span class="comment"># test_list = []</span></span><br><span class="line">        <span class="comment"># for i in range(10000):</span></span><br><span class="line">        <span class="comment">#     w = write(f)</span></span><br><span class="line">        <span class="comment">#     task = asyncio.create_task(w)</span></span><br><span class="line">        <span class="comment">#     test_list.append(task)</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(fun())</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"执行了%d秒"</span> % (end - start))</span><br></pre></td></tr></tbody></table></div></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis封禁账号30分钟</title>
    <url>/id_20/</url>
    <content><![CDATA[<p><strong>问题</strong>： 账号锁定问题  五分钟以内输错五次密码，锁定账号30分钟</p>
<ul>
<li>相关问题：</li>
</ul>
<p><strong>问</strong>：用户登录都有哪些校验方式？<br><strong>答</strong>：</p>
<ul>
<li>用户名和密码 what you know (容易被破解，ant-desgin被黑删库)</li>
<li>用户名和密钥(token)  what you have (gitee可以通过密钥来提交代码)</li>
<li>用户名和实体  who you are  (人脸识别但成本过高)<a id="more"></a></li>
</ul>
<p><strong>问</strong>：为什么要使用redis解决这个问题而不用mysql呢<br><strong>答</strong>：因为使用redis更简单，redis会自动计算时间，mysql需要自己手动将时间入库，比较复杂<br><strong>问题解答</strong>：</p>
<ul>
<li><p>第一步 先判断 用户名+balck 这个key 是否存在</p>
<ul>
<li>存在 意味着已经被锁定 所以直接返回</li>
<li> 不存在 继续执行</li>
</ul>
</li>
<li><p>第二步 向数据库进行请求  登录</p>
<ul>
<li>登录成功 直接返回    </li>
<li>登录不成功 进行redis操作</li>
</ul>
</li>
<li><p>第三步 判断是否是第一次输入错误</p>
<ul>
<li>是 使用incrby进行redis自动累加存储，并expire设置过期时间5分钟，返回输入错误</li>
<li>否 使用get取出用户名这个key的值，判断是否等于5 次<ul>
<li>是 使用set将 用户名+’black’ 这个key存入redis 并expire设置过期时间30分钟，返回账户已锁定</li>
<li>否 使用set用户名更新这个key，并返回输入错误 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK，上代码</p>

        <h3 id="首先-对redis命令进行封装">
          <a href="#首先-对redis命令进行封装" class="heading-link"><i class="fas fa-link"></i></a><a href="#首先-对redis命令进行封装" class="headerlink" title="首先 对redis命令进行封装"></a>首先 对redis命令进行封装</h3>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 封装redis</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRedis</span>:</span></span><br><span class="line">    <span class="comment"># 用来定义属性和变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, **redis_kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.__变量名：使用双下划线开头的变量是私有变量，在类外不可以被调用</span></span><br><span class="line">        <span class="comment"># **kwarys不定长参数  用于可传可不传的参数</span></span><br><span class="line">        <span class="comment"># kwargs是用来传键值对，args 用来传列表和元祖</span></span><br><span class="line"></span><br><span class="line">        self.__db = redis.Redis(**redis_kwargs)</span><br><span class="line"></span><br><span class="line">        self.key = key</span><br><span class="line">    <span class="comment"># 向redis存储数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__db.<span class="built_in">set</span>(self.key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从redis取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.get(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># redis 自动累加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incrby</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__db.incrby(self.key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># redis设置键过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expire</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__db.expire(self.key, value)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="然后写登录视图">
          <a href="#然后写登录视图" class="heading-link"><i class="fas fa-link"></i></a><a href="#然后写登录视图" class="headerlink" title="然后写登录视图"></a>然后写登录视图</h3>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        username = request.data.get(<span class="string">"username"</span>)</span><br><span class="line">        password = request.data.get(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一步 先判断 用户名+balck 这个key 是否存在</span></span><br><span class="line">        <span class="comment"># 存在 意味着已经被锁定 所以直接返回</span></span><br><span class="line">        r = redis.Redis()</span><br><span class="line">        <span class="keyword">if</span> r.get(username + <span class="string">'black'</span>):</span><br><span class="line">            print(r.get(username + <span class="string">'black'</span>))</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"账户已锁定，请等待30分钟后重试"</span>})</span><br><span class="line">        <span class="comment"># 不存在 登录</span></span><br><span class="line">        user = UserModel.objects.<span class="built_in">filter</span>(username=username, password=password).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"登录成功"</span>, <span class="string">"code"</span>: <span class="number">200</span>})</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 判断是否输入错误过</span></span><br><span class="line">            <span class="comment"># 没有</span></span><br><span class="line">            <span class="keyword">if</span> r.get(username) == <span class="literal">None</span>:</span><br><span class="line">                r.incrby(username, <span class="number">1</span>)</span><br><span class="line">                print(<span class="string">"第一次输入错误"</span>)</span><br><span class="line">                r.expire(username, <span class="number">300</span>)</span><br><span class="line">                <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"第一次输入错误"</span>, <span class="string">"code"</span>: <span class="number">400</span>})</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = <span class="built_in">int</span>(r.get(username))</span><br><span class="line">                <span class="comment"># 输入错误五次，加入黑名单</span></span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">5</span>:</span><br><span class="line">                    r.<span class="built_in">set</span>(username + <span class="string">'black'</span>, <span class="number">30</span>)</span><br><span class="line">                    r.expire(username + <span class="string">'black'</span>, <span class="number">1800</span>)</span><br><span class="line">                    <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"输入次数以上限，请30分钟后重试"</span>, <span class="string">'code'</span>: <span class="number">200</span>})</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r.<span class="built_in">set</span>(username, value + <span class="number">1</span>)</span><br><span class="line">                    print(r.get(username))</span><br><span class="line">                    <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"用户名或密码错误，请重新输入"</span>, <span class="string">'code'</span>: <span class="number">400</span>})</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="OK-问题解决了。">
          <a href="#OK-问题解决了。" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-问题解决了。" class="headerlink" title="OK,问题解决了。"></a>OK,问题解决了。</h3>
      ]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>四大推导式(列表/字典/集合/生成器)</title>
    <url>/id_2/</url>
    <content><![CDATA[<p>推导式（又称解析式），是 python 的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列。</p>

        <h3 id="Python-里有四种推导式：">
          <a href="#Python-里有四种推导式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Python-里有四种推导式：" class="headerlink" title="Python 里有四种推导式："></a>Python 里有四种推导式：</h3>
      <ul>
<li>列表推导式(List Comprehensions)</li>
<li>字典推导式(Dictionary Comprehensions)</li>
<li>集合推导式(Set Comprehensions)</li>
<li>生成器推导式(Generator Comprehensions)<a id="more"></a>

</li>
</ul>

        <h4 id="列表推导式">
          <a href="#列表推导式" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4>
      <p>语法：变量名 = [表达式 for 变量 in 列表 if 条件]<br>注意：这里的if不是必须的哦<br><strong>例</strong>：生成一个1-10的列表</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 普通生成</span></span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    x.append(i)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># 列表推导式生成</span></span><br><span class="line">[x.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(x)    </span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>结果同为 [1,2,3,4,5,6,7,8,9,10]</p>
</blockquote>

        <h4 id="字典推导式">
          <a href="#字典推导式" class="heading-link"><i class="fas fa-link"></i></a><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4>
      <p>字典推导式和列表推导式是一样的，只不过把[]换成了{}<br>语法：变量名 = {表达式 for 变量 in 列表 if 条件}<br>注意：这里的if不是必须的哦<br><strong>例</strong>：生成一个只有偶数的字典</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 普通生成</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">y = {}</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        y[i] = <span class="built_in">str</span>(i)      </span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># 字典推导式生成</span></span><br><span class="line">z = {i: <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>}</span><br><span class="line">print(z)   </span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>结果同为 {2:”2”,4:”4”,6:”6”,8:”8”}</p>
</blockquote>

        <h4 id="集合推导式">
          <a href="#集合推导式" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4>
      <p>集合推导式和列表推导式是一样的，同样也是把[]换成了{}<br>语法：变量名 = {表达式 for 变量 in 列表 if 条件}<br>注意：这里的if不是必须的哦<br><strong>例</strong>：生成一个只有奇数的集合</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 普通生成</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">y = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        y.add(i)   </span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># 集合推导式生成</span></span><br><span class="line">[y.add(i) <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>]</span><br><span class="line">print(y)    </span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>结果同为 {1, 3, 5, 7, 9}</p>
</blockquote>

        <h4 id="生成器推导式">
          <a href="#生成器推导式" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h4>
      <p>生成器推导式(或叫生成器表达式)，其结构也跟列表表达式相似。<br>语法：变量名 = (表达式 for 变量 in 列表 if 条件)<br>调用方法：1)for循环<br>        2)next函数<br><strong>例</strong>：将数字列表中各项平方运算，只算偶数</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 普通生成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_even</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> (number * number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">square_numbers = square_even(numbers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> square_numbers:</span><br><span class="line">    print(number)</span><br><span class="line"><span class="comment"># 集合推导式生成</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">square_numbers = (num * num <span class="keyword">for</span> num <span class="keyword">in</span> numbers <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> square_numbers:</span><br><span class="line">    print(number)   </span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>结果同为 4 16 36</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/id_23/</url>
    <content><![CDATA[<p>位运算是一切算法的基础<br>位运算是对二进制进行操作<br>使用位运算来判断奇偶数的时候效率要快一些，性能会高一些，因为二进制是计算机识别的语言，计算机不需要去强转然后判断，直接判断即可<br>例如；判断4是不是奇数或偶数</p>
<a id="more"></a>
<p>可以二进制直接和1进行比较<br>0b100 &amp; 1<br>0<br>也可以使用十进制直接和1比较<br>4 &amp; 1<br>0</p>
<blockquote>
<p> 返回为0 证明是偶数</p>
</blockquote>
<p>0b11 &amp; 1<br>1<br>3 &amp; 1<br>1</p>
<blockquote>
<p>返回为1 证明是奇数 </p>
</blockquote>

        <h4 id="运算符">
          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4>
      <p>符号    描述    运算规则<br>&amp;    与    两个位都为1时，结果才为1<br>|    或    两个位都为0时，结果才为0<br>^    异或    两个位相同为0，相异为1<br>~    取反    0变1，1变0</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>异步消费</title>
    <url>/id_22/</url>
    <content><![CDATA[<p>异步消费可以使用很多方式来实现，我们今天就来说说异步消费的其中三种实现方式:</p>
<ul>
<li>多线程</li>
<li>线程池</li>
<li>协程<a id="more"></a>

</li>
</ul>

        <h4 id="首先，将封装的代码及逻辑写上">
          <a href="#首先，将封装的代码及逻辑写上" class="heading-link"><i class="fas fa-link"></i></a><a href="#首先，将封装的代码及逻辑写上" class="headerlink" title="首先，将封装的代码及逻辑写上"></a>首先，将封装的代码及逻辑写上</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="comment"># 队列遵循先进先出的原则</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, **redis_kwargs</span>):</span></span><br><span class="line">        <span class="comment"># **kwarys不定长参数  用于可传可不传的参数 </span></span><br><span class="line">        <span class="comment"># kwargs是用来传键值对，args 一般用来传列表和元祖</span></span><br><span class="line">        <span class="comment"># self.__变量名：使用双下划线开头的变量是私有变量，在类外不可以被调用</span></span><br><span class="line">        <span class="comment"># redis的默认参数为：host='localhost', port=6379, db=0， 其中db为定义redis的第几个库</span></span><br><span class="line">        self.__db = redis.Redis(**redis_kwargs, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.key = name</span><br><span class="line">        <span class="comment"># llen:获取列表长度</span></span><br><span class="line">        <span class="comment"># lrange:获取列表指定范围内的元素</span></span><br><span class="line">        self.r_len = self.__db.llen(self.key)</span><br><span class="line">        self.l = self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">tuple</span></span>):</span></span><br><span class="line">        <span class="comment"># rpush:在列表中添加一个或多个值</span></span><br><span class="line">        self.__db.rpush(self.key, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 排序用来加权(加权是celery没有的)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 因为redis里存的是字符串，而排序的依据是元组中最后一个元素为int,所以使用-2下标</span></span><br><span class="line">        <span class="comment"># 此处可用eval </span></span><br><span class="line">        self.l = <span class="built_in">sorted</span>(self.l, key=<span class="keyword">lambda</span> x: x[-<span class="number">2</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># pop(0):移出并获取列表的第一个元素</span></span><br><span class="line">        <span class="comment"># lrem 根据第二个参数的值，移除列表中与参数相等的元素。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.l:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        item = self.l.pop(<span class="number">0</span>)</span><br><span class="line">        self.__db.lrem(self.key, item, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 用来清空列表</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.delete(self.key)</span><br><span class="line"></span><br><span class="line">q = MyQueue(<span class="string">"que"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    q.push((i, i + <span class="number">1</span>, i + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dojob</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        result = q.pop()</span><br><span class="line">        <span class="comment"># 写逻辑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(result)</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="使用多线程实现异步消费">
          <a href="#使用多线程实现异步消费" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用多线程实现异步消费" class="headerlink" title="使用多线程实现异步消费"></a>使用多线程实现异步消费</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 创建三个线程</span></span><br><span class="line">    thread = threading.Thread(target=dojob) <span class="comment">#调用任务</span></span><br><span class="line">    thread.start() <span class="comment"># 开启线程</span></span><br><span class="line">print(q.r_len)</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="使用线程池实现异步消费">
          <a href="#使用线程池实现异步消费" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用线程池实现异步消费" class="headerlink" title="使用线程池实现异步消费"></a>使用线程池实现异步消费</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment"># 设置线程数最大为5</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> t:</span><br><span class="line">        [t.submit(dojob) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对iterables执行map处理</span></span><br><span class="line">        <span class="comment"># 可以通过submit提交执行的函数到线程池中</span></span><br><span class="line"><span class="comment"># 线程池是系统来给分配任务</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="使用协程实现异步消费">
          <a href="#使用协程实现异步消费" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用协程实现异步消费" class="headerlink" title="使用协程实现异步消费"></a>使用协程实现异步消费</h4>
      <p>协程本质上就是一个线程，以前线程任务的切换是由操作系统控制的，遇到I/O自动切换，现在我们用协程的目的就是较少操作系统切换的开销（开关线程，创建寄存器、堆栈等，在他们之间进行切换等），在我们自己的程序里面来控制任务的切换<br>优点：</p>
<ol>
<li>协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</li>
<li>单线程内就可以实现并发的效果，最大限度地利用cpu</li>
</ol>
<p>缺点：</p>
<ol>
<li>协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程</li>
<li>协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 协程也是一种单线程，只不过是用户来给分配任务</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># 创建事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 运行事件循环，直到dojob运行结束</span></span><br><span class="line">res = loop.run_until_complete(dojob())</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现消息队列(Queue)</title>
    <url>/id_21/</url>
    <content><![CDATA[<ul>
<li>相关问题：</li>
</ul>
<p><strong>问</strong>：为什么能用列表推导式的时候不用普通for循环？<br><strong>答</strong>：列表推导式比普通for循环性能好</p>
<a id="more"></a>
<p><strong>问</strong>：什么是lambda表达式？怎么用？<br><strong>答</strong>：lambda表达式又被称为匿名函数，一般在执行简单的逻辑时使用<br>lambda x:x<em>x   lambda关键字 x变量 x</em>x逻辑<br>注意：lambda的使用大量简化了代码，使代码简练清晰。但是值得注意的是，这会在一定程度上降低代码的可读性。还有lambda内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。<br><strong>问</strong>：redis列表里只能存字符串，如果想存别的类型有什么办法？<br><strong>答</strong>：使用eval()</p>
<blockquote>
<p>eval() 原样输出字符串，将字符串强转成它包含的数据类型<br>例: a = “[1,2,3]”(字符串)<br>    a = eval(a)<br>结果：a=<a href="%E5%88%97%E8%A1%A8">1,2,3</a></p>
</blockquote>
<p><strong>加权队列</strong>：举个例子吧，在银行窗口办理业务的时候需要先取号==放进队列，然后排队等待。<br>但是这只是普通用户。如果有金卡用户取号，那么金卡用户的业务就可以插队==加权，先行办理金卡用户的业务<br>加权需要用到排序，并且Celery并没有加权这一功能<br>上代码！</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 首先进行方法封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="comment"># 队列遵循先进先出的原则</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, **redis_kwargs</span>):</span></span><br><span class="line">        <span class="comment"># **kwarys不定长参数  用于可传可不传的参数 </span></span><br><span class="line">        <span class="comment"># kwargs是用来传键值对，args 一般用来传列表和元祖</span></span><br><span class="line">        <span class="comment"># self.__变量名：使用双下划线开头的变量是私有变量，在类外不可以被调用</span></span><br><span class="line">        <span class="comment"># redis的默认参数为：host='localhost', port=6379, db=0， 其中db为定义redis的第几个库</span></span><br><span class="line">        self.__db = redis.Redis(**redis_kwargs, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.key = name</span><br><span class="line">        <span class="comment"># llen:获取列表长度</span></span><br><span class="line">        <span class="comment"># lrange:获取列表指定范围内的元素</span></span><br><span class="line">        self.r_len = self.__db.llen(self.key)</span><br><span class="line">        self.l = self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">tuple</span></span>):</span></span><br><span class="line">        <span class="comment"># rpush:在列表中添加一个或多个值</span></span><br><span class="line">        self.__db.rpush(self.key, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 排序用来加权(加权是celery没有的)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 因为redis里存的是字符串，而排序的依据是元组中最后一个元素为int,所以使用-2下标</span></span><br><span class="line">        <span class="comment"># 此处可用eval </span></span><br><span class="line">        self.l = <span class="built_in">sorted</span>(self.l, key=<span class="keyword">lambda</span> x: x[-<span class="number">2</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># pop(0):移出并获取列表的第一个元素</span></span><br><span class="line">        <span class="comment"># lrem 根据第二个参数的值，移除列表中与参数相等的元素。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.l:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        item = self.l.pop(<span class="number">0</span>)</span><br><span class="line">        self.__db.lrem(self.key, item, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 用来清空列表</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.delete(self.key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    m = MyQueue(<span class="string">'que'</span>)</span><br><span class="line">    <span class="comment"># 添加到redis</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 列表推导式</span></span><br><span class="line">    [m.push(i,i+<span class="number">1</span>,i+<span class="number">2</span>) <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) i++]</span><br><span class="line">    <span class="comment"># 将添加进去的数据排序 </span></span><br><span class="line">    m.sort()</span><br><span class="line">    <span class="comment"># 删除排序后列表中的第一个元素</span></span><br><span class="line">    m.pop()</span><br><span class="line">    <span class="comment"># 清空列表</span></span><br><span class="line">    m.clear()</span><br></pre></td></tr></tbody></table></div></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB安装与使用</title>
    <url>/id_24/</url>
    <content><![CDATA[<h4 id="MongoDB安装">
          <a href="#MongoDB安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h4>
      <p>MongoDB安装方式</p>
<ul>
<li>将MongoDB服务下载下来 安装到自己的电脑<a id="more"></a>

        <h5 id="MongoDB服务下载并安装">
          <a href="#MongoDB服务下载并安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#MongoDB服务下载并安装" class="headerlink" title="MongoDB服务下载并安装"></a>MongoDB服务下载并安装</h5>
      </li>
</ul>
<p>进入<span class="exturl"><a class="exturl__link" href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 这个链接去下载，<br>下载完成后，会得到一个后缀为.msi的文件，双击进行安装即可<br><strong>注意</strong>：不去掉勾选的话可能会安装特别慢，四五个小时都有可能<br><img src="/id_24/01.jpg" alt="注意"><br>详细安装过程可参考菜鸟教程<br><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/mongodb/mongodb-window-install.html">https://www.runoob.com/mongodb/mongodb-window-install.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="MongoDB-Compass（可视化工具）安装">
          <a href="#MongoDB-Compass（可视化工具）安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#MongoDB-Compass（可视化工具）安装" class="headerlink" title="MongoDB Compass（可视化工具）安装"></a>MongoDB Compass（可视化工具）安装</h5>
      <p>进入 <span class="exturl"><a class="exturl__link" href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 这个链接下载可视化工具<br>下载完成后，会得到一个压缩文件，解压到任意文件夹里即可，<br>压缩包解压之后，上方有一个MongoDBCompass.exe文件，打开即可</p>
<p>MongoDB使用</p>
<p>基本语法</p>
<div class="table-container"><table>
<thead>
<tr>
<th>命令</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>创建数据库</td>
<td>use 数据库名</td>
</tr>
<tr>
<td>展示所有数据库</td>
<td>show dbss</td>
</tr>
<tr>
<td>查看当前所在数据库</td>
<td>db</td>
</tr>
<tr>
<td>创建集合</td>
<td>db.createCollection(‘集合’)</td>
</tr>
<tr>
<td>展示集合</td>
<td>show 集合名</td>
</tr>
<tr>
<td>插入数据</td>
<td>db.集合.insert({…})</td>
</tr>
<tr>
<td>读取数据</td>
<td>db.集合.find()</td>
</tr>
<tr>
<td>读取指定数据</td>
<td>db.集合.find({id:1})</td>
</tr>
<tr>
<td>读取一条数据</td>
<td>db.集合.find_one({id:1})</td>
</tr>
</tbody></table></div>

        <h4 id="python操作MongoDB">
          <a href="#python操作MongoDB" class="heading-link"><i class="fas fa-link"></i></a><a href="#python操作MongoDB" class="headerlink" title="python操作MongoDB"></a>python操作MongoDB</h4>
      <ul>
<li>下载python中的MongoDB<blockquote>
<p>pip install pymongo</p>
</blockquote>
</li>
</ul>
<p>下载完成之后，进行连接（此处要导包）</p>
<blockquote>
<p>from pymongo import MongoClient<br>client = MongoClient(host=’127.0.0.1’, port=27017)</p>
</blockquote>
<p>接下来需要进入我们在MongoDB创建的数据库(mongotest)<br>此处没有创建数据库的，需要手动创建MongoDB数据库（看上方的基本语法）</p>
<blockquote>
<p>db = client.mongotest</p>
</blockquote>
<p>指定集合</p>
<blockquote>
<p>table = db.CateTemplate</p>
</blockquote>
<p>建立好之后，就可以进行查询了</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">    <span class="comment"># 进入数据库</span></span><br><span class="line">    db = client.mongotest</span><br><span class="line">    <span class="comment"># 集合</span></span><br><span class="line">    dbset = db.CateTemplate</span><br><span class="line">    <span class="built_in">id</span> = request.GET.get(<span class="string">'id'</span>, <span class="literal">None</span>)</span><br><span class="line">    tid = WorkOrderModel.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="built_in">id</span>).first()</span><br><span class="line">    data = {}</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> zst.find({<span class="string">'tid'</span>: <span class="built_in">str</span>(tid.pid)}):</span><br><span class="line">        data = <span class="built_in">eval</span>(i[<span class="string">'name'</span>])</span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="OK">
          <a href="#OK" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK" class="headerlink" title="OK"></a>OK</h4>
      ]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的使用</title>
    <url>/id_25/</url>
    <content><![CDATA[<h3 id="栈">
          <a href="#栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈" class="headerlink" title="栈"></a>栈</h3>
      <p>栈（stack）又名堆栈，它是一种运算受限的<strong>线性表</strong>。限定仅在表尾进行插入和删除操作的线性表。<br>这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；<br>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<a id="more"></a>
<p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。<br>它按照<strong>先进后出</strong>，<strong>后进先出</strong>的原则存储数据</p>

        <h4 id="应用场景">
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4>
      <ul>
<li>银行ATM自动存取款机<br>  假设取款机下有一个用来钱的箱子，箱子只有一个口供用户存取现金<br>  当你存钱的时候，ATM会把钱放在最上面<br>  当你取钱的时候，ATM会把最上面的钱吐出来</li>
</ul>

        <h4 id="案例">
          <a href="#案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例" class="headerlink" title="案例"></a>案例</h4>
      
        <h5 id="将十进制的数转换为二进制的数">
          <a href="#将十进制的数转换为二进制的数" class="heading-link"><i class="fas fa-link"></i></a><a href="#将十进制的数转换为二进制的数" class="headerlink" title="将十进制的数转换为二进制的数"></a>将十进制的数转换为二进制的数</h5>
      <p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为二进制，将十进制数除以2，记录余数，然后继续将商除以2，一直到商等于0为止，最后将余数倒着写数来就可以了。</p>
<p>比如13的二进制，13首先除以2商6余1,1首先进栈，然后6除以2商3余0，第二个余数0进栈，接着3除以2，商1余1，第三个余数1进栈，继续1除以2商0余1，第四个余数1进栈。最后将四个余数出栈，就得到了13的二进制1101。<br>实现代码如下</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.item = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        self.item.append(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.item) != <span class="number">0</span>:</span><br><span class="line">                print(self.item.pop(),end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exe</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        key = <span class="built_in">int</span>(key)</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            self.push(key % <span class="number">2</span>)</span><br><span class="line">            key //= <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> key == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Stack()</span><br><span class="line">s.exe(<span class="built_in">input</span>(<span class="string">"请输入您要进行换算的数字："</span>))</span><br><span class="line">s.pop()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="栈和队列的异同点">
          <a href="#栈和队列的异同点" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈和队列的异同点" class="headerlink" title="栈和队列的异同点"></a>栈和队列的异同点</h3>
      
        <h4 id="首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。">
          <a href="#首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。" class="heading-link"><i class="fas fa-link"></i></a><a href="#首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。" class="headerlink" title="首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。"></a>首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。</h4>
      
        <h4 id="栈与队列的相同点：">
          <a href="#栈与队列的相同点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈与队列的相同点：" class="headerlink" title="栈与队列的相同点："></a>栈与队列的相同点：</h4>
      <p>1.都是线性结构。<br>2.插入操作都是限定在表尾进行。<br>3.都可以通过顺序结构和链式结构实现。<br>4.插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。<br>5.多链栈和多链队列的管理模式可以相同。</p>

        <h4 id="栈与队列的不同点：">
          <a href="#栈与队列的不同点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈与队列的不同点：" class="headerlink" title="栈与队列的不同点："></a>栈与队列的不同点：</h4>
      <p>1.删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。<br>2.应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。<br>3.顺序栈能够实现多栈空间共享，而顺序队列不能。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>进制</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/id_26/</url>
    <content><![CDATA[<h4 id="设计模式简介">
          <a href="#设计模式简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h4>
      <p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>

        <h4 id="设计模式有三大类：">
          <a href="#设计模式有三大类：" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计模式有三大类：" class="headerlink" title="设计模式有三大类："></a>设计模式有三大类：</h4>
      <ol>
<li>创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。</li>
<li>结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。</li>
<li>行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。</li>
</ol>
<a id="more"></a>
<p><strong>创建型</strong></p>
<ol>
<li><p>Factory Method（工厂方法）</p>
</li>
<li><p>Abstract Factory（抽象工厂）</p>
</li>
<li><p>Builder（建造者）</p>
</li>
<li><p>Prototype（原型）</p>
</li>
<li><p>Singleton（单例）</p>
</li>
</ol>
<p><strong>结构型</strong></p>
<ol start="6">
<li><p>Adapter Class/Object（适配器）</p>
</li>
<li><p>Bridge（桥接）</p>
</li>
<li><p>Composite（组合）</p>
</li>
<li><p>Decorator（装饰）</p>
</li>
<li><p>Facade（外观）</p>
</li>
<li><p>Flyweight（享元）</p>
</li>
<li><p>Proxy（代理）</p>
</li>
</ol>
<p><strong>行为型</strong></p>
<ol start="13">
<li><p>Interpreter（解释器）</p>
</li>
<li><p>Template Method（模板方法）</p>
</li>
<li><p>Chain of Responsibility（责任链）</p>
</li>
<li><p>Command（命令）</p>
</li>
<li><p>Iterator（迭代器）</p>
</li>
<li><p>Mediator（中介者）</p>
</li>
<li><p>Memento（备忘录）</p>
</li>
<li><p>Observer（观察者）</p>
</li>
<li><p>State（状态）</p>
</li>
<li><p>Strategy（策略）</p>
</li>
<li><p>Visitor（访问者）</p>
</li>
</ol>
<ul>
<li>
        <h4 id="这里我们挑两个做例子">
          <a href="#这里我们挑两个做例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#这里我们挑两个做例子" class="headerlink" title="这里我们挑两个做例子"></a>这里我们挑两个做例子</h4>
      </li>
</ul>
<p><strong>１．Factory Method（工厂方法）</strong><br><strong>意图：</strong><br>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。<br>工厂模式是用来解耦的<br>在工单审批中，使用工厂模式将串审和并审都封装起来，使用工厂模式来判断是串审还是并审，工厂模式还可以用来三方登录<br><strong>适用性：</strong><br>当一个类不知道它所必须创建的对象的类的时候。<br>当一个类希望由它的子类来指定它所创建的对象的时候。<br>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 </p>
<p><img src="/id_26/%E5%B7%A5%E5%8E%82.png" alt="工厂模式"></p>
<p><strong>实现：</strong></p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="comment"># 用于显示，return的数据repr会自动帮你打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'小汽车'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 口罩</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mask</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"口罩"</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span>:</span></span><br><span class="line">    <span class="comment"># 装饰器  静态方法</span></span><br><span class="line">    <span class="comment"># 类方法需用用类实例调用。静态方法不需要类实例，直接通过类名就可以调用</span></span><br><span class="line">    <span class="comment"># product 产品</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">"小汽车"</span>:</span><br><span class="line">            <span class="keyword">return</span> Car()</span><br><span class="line">        <span class="keyword">elif</span> name == <span class="string">'口罩'</span>:</span><br><span class="line">            <span class="keyword">return</span> Mask()</span><br><span class="line"></span><br><span class="line">print(SimpleFactory.product(<span class="string">'小汽车'</span>))</span><br><span class="line">print(SimpleFactory.product(<span class="string">"口罩"</span>))</span><br></pre></td></tr></tbody></table></div></figure>




<p><strong>2. Singleton（单例）</strong><br><strong>意图：</strong><br>单例模式是为了提高性能<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>因为每个实例的内存地址都不一样，如果每个实例都开辟一块内存空间的话，内存会爆掉 </p>
<p><strong>适用性：</strong><br>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p>
<p><img src="/id_26/%E5%8D%95%E4%BE%8B.png" alt="单例模式"></p>
<p><strong>实现：</strong></p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Singleton</span>(<span class="params">cls</span>):</span>  <span class="comment"># 这是一个函数，目的是要实现一个“装饰器”，而且是对类型的装饰器</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    cls:表示一个类名，即所要设计的单例类名称，</span></span><br><span class="line"><span class="string">        因为python一切皆对象，故而类名同样可以作为参数传递</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    instance = {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">*args, **kargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">            instance[cls] = cls(*args, **kargs)  <span class="comment"># 如果没有cls这个类，则创建，并且将这个cls所创建的实例，保存在一个字典中</span></span><br><span class="line">        <span class="keyword">return</span> instance[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> singleton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">'张三'</span>, <span class="number">23</span>)</span><br><span class="line">s2 = Student(<span class="string">'李四'</span>, <span class="number">24</span>)</span><br><span class="line">print((s1 == s2))</span><br><span class="line">print(s1 <span class="keyword">is</span> s2)</span><br><span class="line">print(<span class="built_in">id</span>(s1), <span class="built_in">id</span>(s2), sep=<span class="string">'   '</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __new__方法实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, age</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            cls.instance = <span class="built_in">super</span>(Student, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">'张三'</span>, <span class="number">23</span>)</span><br><span class="line">s2 = Student(<span class="string">'李四'</span>, <span class="number">24</span>)</span><br><span class="line">print((s1 == s2))</span><br><span class="line">print(s1 <span class="keyword">is</span> s2)</span><br><span class="line">print(<span class="built_in">id</span>(s1), <span class="built_in">id</span>(s2), sep=<span class="string">'   '</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>引用计数</title>
    <url>/id_27/</url>
    <content><![CDATA[<h3 id="引用计数">
          <a href="#引用计数" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3>
      
        <h5 id="问">
          <a href="#问" class="heading-link"><i class="fas fa-link"></i></a><a href="#问" class="headerlink" title="问"></a>问</h5>
      <p>引用计数这个问题是我们在面试中经常会遇到的。通常面试官会这样问：</p>
<ol>
<li>python中是如何管理内存的？</li>
<li>你知道引用计数吗？<a id="more"></a>

</li>
</ol>

        <h5 id="答">
          <a href="#答" class="heading-link"><i class="fas fa-link"></i></a><a href="#答" class="headerlink" title="答"></a>答</h5>
      <p>引用计数是内存管理机制，将资源的使用次数保存起来，在引用次数变为<strong>零</strong>时进行释放</p>
<p>比如说我们现在有一个变量a，指向内存中的字符 ‘x’ ，此时x在内存中的引用计数为1，然后又有一个变量b，b=a</p>
<p>此时(b=a)和(a=’x’)是相等的，那这个时候x在内存中的引用计数就会+1变为2</p>
<p><img src="/id_27/%E4%BE%8B.png" alt="案例"></p>

        <h4 id="引用计数的好处">
          <a href="#引用计数的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数的好处" class="headerlink" title="引用计数的好处"></a>引用计数的好处</h4>
      <p>我们可以举一些生活中的场景，比如说我们出去<strong>旅游</strong>，朋友提前抵达并开好了房间，这样我们就可以免费跟朋友住一间房，这样既节约了我们的时间，又节约了我们另外开房需要支付的资金。</p>
<ul>
<li>可知：减少了内存碎片的产生，</li>
<li>并且可以对于我们在创建和释放内存中有一定的资源开销的节省。</li>
<li>可以更快的进行资源管理</li>
</ul>
<p>那同样，当我们旅途结束，不需要再居住的时候，所有人离开酒店，那这个房间就会被酒店的人员进行清理，处理。</p>
<ul>
<li>这样就像引用计数中计数为0时，内存会被回收掉是一样的</li>
</ul>

        <h4 id="查看引用计数">
          <a href="#查看引用计数" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看引用计数" class="headerlink" title="查看引用计数"></a>查看引用计数</h4>
      <p>查看引用计数我们是使用了sys模块中getrefcount方法<br>sys.getrefcount返回的计数，总是比实际多1，因为包含了调用此函数的临时计数。</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\Lenovo&gt;python.exe</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.0</span> (v3<span class="number">.7</span><span class="number">.0</span>:1bf9cc5093, Jun <span class="number">27</span> <span class="number">2018</span>, 04:<span class="number">59</span>:<span class="number">51</span>) [MSC v<span class="number">.1914</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">119</span></span><br><span class="line"><span class="comment"># 得出常量1在内存中的引用计数为119</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="那什么时候会用到引用计数呢">
          <a href="#那什么时候会用到引用计数呢" class="heading-link"><i class="fas fa-link"></i></a><a href="#那什么时候会用到引用计数呢" class="headerlink" title="那什么时候会用到引用计数呢"></a>那什么时候会用到引用计数呢</h4>
      <p>当发生以下四种情况的时候，该对象的引用计数器+1</p>
<p>对象被创建 a=14<br>对象被引用 b=a<br>对象被作为参数,传到函数中 func(a)<br>对象作为一个元素，存储在容器中  List={a,”a”,”b”,2}</p>

        <h5 id="取两点举例：">
          <a href="#取两点举例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#取两点举例：" class="headerlink" title="取两点举例："></a>取两点举例：</h5>
      <p>1、 变量互相赋值的时候</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'x'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">3242716434928</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">3242716434928</span></span><br><span class="line"><span class="comment"># 此时我们可以看出两个变量指向的内存地址是完全一样的 。可得变量互相赋值的时候用到了引用计数</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>2、常用对象创建时</p>
<p>python本身含有a-z,A-Z,0-9等常见值的引用</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140707666383904</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140707666383904</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">140707666383904</span></span><br><span class="line"><span class="comment"># 此时我们可以看出a,b,c的内存地址都是完全一致的， 可得常用对象创建时用到了引用计数</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="如何减少引用次数">
          <a href="#如何减少引用次数" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何减少引用次数" class="headerlink" title="如何减少引用次数"></a>如何减少引用次数</h4>
      <p>与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1</p>
<p>当该对象的别名被显式销毁时 del a<br>当该对象的引别名被赋予新的对象，  a=26<br>一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）<br>将该元素从容器中删除时，或者容器被销毁时。</p>
<p>.当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁</p>

        <h5 id="取两点举例">
          <a href="#取两点举例" class="heading-link"><i class="fas fa-link"></i></a><a href="#取两点举例" class="headerlink" title="取两点举例:"></a>取两点举例:</h5>
      <p>1、变量被重新赋值为别的值</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="comment"># 可以看出，当a被重新赋值后再次查看1的引用计数是减少了1的</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>2、del  删除变量</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="comment"># 可以看出，当a被del删除后再次查看1的引用计数是减少了1的</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="引用计数的缺点">
          <a href="#引用计数的缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数的缺点" class="headerlink" title="引用计数的缺点"></a>引用计数的缺点</h4>
      <p>那引用计数真的这么完美吗，不占内存地址，用完即释放，nonono,当然不是</p>
<p>引用计数最大的缺点就是<strong>循环引用</strong></p>
<p>那循环引用是什么呢？</p>
<p>循环引用就是两个变量互相引用时假设已经被释放，但引用计数不为0，那就会导致这两个变量无法被直接回收<br>循环引用可以使一种引用对象的引用计数不为0，然而这些对象实际上并没有被任何外部对象所引用，它们之间只是相互引用，这意味着这组对象所占用的内存空间是应该被回收的，但是由于循环引用导致的引用计数不为0，所以这组对象所占用的内存空间永远不会被释放</p>
<p><strong>那循环引用有什么解决办法吗？</strong></p>
<p>那肯定是有的，python中解决循环引用的方法就是<strong>标记-清除</strong><br>请移步下一节：<a href="https://www.hr915.xyz/id_28">https://www.hr915.xyz/id_28</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收机制之标记-清除</title>
    <url>/id_28/</url>
    <content><![CDATA[<h3 id="垃圾回收机制">
          <a href="#垃圾回收机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3>
      <p>垃圾自动回收机制的出现使编程更加的简单，使得我们不需要再去考虑内存分配和释放的问题，而是更加的专注在我们产品功能的实现上</p>
<p>目前最基本的垃圾收集算法有四种,标记-清除算法(mark-sweep),标记-压缩算法(mark-compact),复制算法(copying)以及引用计数算法(reference counting).而现代流行的垃圾收集算法一般是由这四种中的其中几种算法相互组合而成，比如说，对堆(heap)的一部分采用标记-清除算法，对堆(heap)的另外一部分则采用复制算法等等。今天我们主要来看下标记-清除算法的原理。</p>
<a id="more"></a>

        <h4 id="标记-清除">
          <a href="#标记-清除" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4>
      <p>标记-清除算法分为两个阶段，标记(mark)和清除(sweep)</p>

        <h5 id="标记：">
          <a href="#标记：" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记：" class="headerlink" title="标记："></a>标记：</h5>
      <p>在内存中对每一个被使用到的变量来进行标记</p>
<p>标记是从根对象开始工作，所有能够和根对象联系的变量我们都会有相应的标记。</p>

        <h5 id="标记举例">
          <a href="#标记举例" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记举例" class="headerlink" title="标记举例"></a>标记举例</h5>
      <p><img src="/id_28/01.png" alt="标记"></p>
<p><img src="/id_28/02.png" alt="标记"></p>
<p><img src="/id_28/03.png" alt="标记"></p>

        <h5 id="清除">
          <a href="#清除" class="heading-link"><i class="fas fa-link"></i></a><a href="#清除" class="headerlink" title="清除:"></a>清除:</h5>
      <p>清除主要是将内存中无关联根对象的并且没有被标记的变量给杀死，释放掉</p>
<p><img src="/id_28/04.png" alt="image-20210324190403266"></p>
<p>图中a和b已经和根对象没有关系了，而且并没有被标记，所以就会被清除掉</p>

        <h4 id="总结：">
          <a href="#总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4>
      <p>总的来说，在标记-清除过程中,他会扫描整个内存空间，扫描过程中python程序会暂停，被标记的对象不会被回收，没有标记的对象会被回收掉。<br>但是我们整个python程序暂停，暂停会导致程序无法正常运行，让程序运行时出现一些问题从而造成程序阻塞问题<br>那python呢就引入了<strong>分代回收</strong>来避免标记-清除，由于每一次过程都需要去大量的遍历整块内存而造成的程序阻塞问题</p>
<p>分代回收参考下一篇文章：<a href="https://www.hr915.xyz/id_29">https://www.hr915.xyz/id_29</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>分代回收</title>
    <url>/id_29/</url>
    <content><![CDATA[<h3 id="分代回收">
          <a href="#分代回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3>
      <p>标记-清除会在大规模遍历内存中会使程序暂停 ，程序暂停会导致我们程序出现很多我们意想不到的错误和问题出现，所以pyt hon引入了我们的分代回收来解决这个问题，分代回收也应该是我们在面试过程中主动向面试官阐述出来的。</p>
<a id="more"></a>

        <h4 id="分代回收原理：">
          <a href="#分代回收原理：" class="heading-link"><i class="fas fa-link"></i></a><a href="#分代回收原理：" class="headerlink" title="分代回收原理："></a>分代回收原理：</h4>
      <p>分代回收主要是将我们的内存根据对象的时候或被标记的次数进行分代他是一种典型是<strong>时间换空间</strong>的行为，那么他主要分为三代，<strong>青年代</strong>、<strong>中年代</strong>、<strong>老年代</strong>。那么我们可以认为一个对象在内存中存在的时间越长，越不容易被回收，越不是一个垃圾，这里我们认为<strong>老年代</strong>是存活在三代中最长的，那也是最不容易被回收掉的。</p>

        <h4 id="举例说明">
          <a href="#举例说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4>
      <p>那么我们可以来看一下，假设下图是一块内存： </p>
<p><img src="/id_29/01.png" alt="内存"></p>
<p>那我们现在有一个变量a=1首先进入青年代，然后陆陆续续的我们会有变量存入青年代之后，青年代觉得他自己快要满了，那么此时会触发我们的标记清除动作。</p>
<p><img src="/id_29/02.png" alt="青年代"></p>
<p>那么触发我们的回收机制，标记-清除之后会在青年代中找到所有引用计数为0的元素，并将其释放。把剩余可以继续往下的元素沉淀到中年代，那么这就是分代回收的技术。</p>
<p><img src="/id_29/03.png" alt="沉淀中年代"></p>
<p>他是结合了我们引用计数和标记清除在内的，那每一次对比于之前，现在我们标记清除不需要遍历整段内存，只需要将其对应代遍历即可，那么这样就间接节约了我们遍历所花费的暂停时间，让我们的程序尽可能不要的过多整段内存去遍历，去过滤。</p>
<p>那么当然呢，更加细节的来说：</p>
<ul>
<li>其实是在我们的第0代，也就是青年代满的时候呢将会触发清理我们所有的三代，</li>
<li>而在中年代满时，将会触发清理我们的中年代和老年代，</li>
<li>而在我们老年代满的时候呢，只会触发清理我们的老年代，</li>
<li>也就是说呢，每一层在满了之后，他就会触发<strong>当前及当前之后的每代</strong>的回收动作，</li>
</ul>
<p><strong>目的</strong>：那么分代回收他的主要目的是为了解决我们标记-清除所带来的一些额外操作，我们上一节也说过，标记-清除如果需要遍历的内存节点较多的时候，那么每一次回收他都要花费大量的时间，那么利用我们的分代回收就可以减少这些情况</p>

        <h4 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h4>
      <p>我们python管理内存是以引用计数为主，标记清除和分代回收为辅的方法来管理内存的</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/id_3/</url>
    <content><![CDATA[<p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p>
<p>接下来我们学习一下如何使用 Gitee。</p>
<a id="more"></a>

        <h3 id="Git-的工作流程。">
          <a href="#Git-的工作流程。" class="heading-link"><i class="fas fa-link"></i></a><a href="#Git-的工作流程。" class="headerlink" title="Git 的工作流程。"></a>Git 的工作流程。</h3>
      <p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p><img src="/id_3/4.png" alt="git"></p>

        <h3 id="首先登录Gitee">
          <a href="#首先登录Gitee" class="heading-link"><i class="fas fa-link"></i></a><a href="#首先登录Gitee" class="headerlink" title="首先登录Gitee"></a>首先登录Gitee</h3>
      <p><span class="exturl"><a class="exturl__link" href="https://gitee.com/">https://gitee.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><img src="/id_3/1.png" alt="登录Git"></p>

        <h3 id="新建仓库">
          <a href="#新建仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3>
      <p><img src="/id_3/2.png" alt="新建仓库"><br><img src="/id_3/3.png" alt="新建仓库"></p>

        <h2 id="git常用命令">
          <a href="#git常用命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2>
      
        <h5 id="将存储库的内容克隆到本地">
          <a href="#将存储库的内容克隆到本地" class="heading-link"><i class="fas fa-link"></i></a><a href="#将存储库的内容克隆到本地" class="headerlink" title="将存储库的内容克隆到本地"></a>将存储库的内容克隆到本地</h5>
      <blockquote>
<p>git clone 链接地址</p>
</blockquote>

        <h5 id="首先-作为-git-的基础配置，作用是告诉-git-你是谁，你输入的信息将出现在你创建的提交中。然后初始化项目">
          <a href="#首先-作为-git-的基础配置，作用是告诉-git-你是谁，你输入的信息将出现在你创建的提交中。然后初始化项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#首先-作为-git-的基础配置，作用是告诉-git-你是谁，你输入的信息将出现在你创建的提交中。然后初始化项目" class="headerlink" title="首先,作为 git 的基础配置，作用是告诉 git 你是谁，你输入的信息将出现在你创建的提交中。然后初始化项目"></a>首先,作为 git 的基础配置，作用是告诉 git 你是谁，你输入的信息将出现在你创建的提交中。然后初始化项目</h5>
      <blockquote>
<p> git config - -global user.name “你的名字或昵称”<br> git config - -global user.email “你的邮箱”<br>git init</p>
</blockquote>

        <h5 id="将所有内容添加到暂存区-代表所有">
          <a href="#将所有内容添加到暂存区-代表所有" class="heading-link"><i class="fas fa-link"></i></a><a href="#将所有内容添加到暂存区-代表所有" class="headerlink" title="将所有内容添加到暂存区     .代表所有"></a>将所有内容添加到暂存区     .代表所有</h5>
      <blockquote>
<p>git add .</p>
</blockquote>

        <h5 id="存储库记录更改">
          <a href="#存储库记录更改" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储库记录更改" class="headerlink" title="存储库记录更改"></a>存储库记录更改</h5>
      <blockquote>
<p>git commit -m “更改说明”</p>
</blockquote>

        <h5 id="将仓库和服务器连接">
          <a href="#将仓库和服务器连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#将仓库和服务器连接" class="headerlink" title="将仓库和服务器连接"></a>将仓库和服务器连接</h5>
      <blockquote>
<p>git remote add origin 链接地址</p>
</blockquote>

        <h5 id="删除远程地址">
          <a href="#删除远程地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除远程地址" class="headerlink" title="删除远程地址"></a>删除远程地址</h5>
      <blockquote>
<p>git remote rm origin</p>
</blockquote>

        <h5 id="将本地仓库提交到远程仓库">
          <a href="#将本地仓库提交到远程仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#将本地仓库提交到远程仓库" class="headerlink" title="将本地仓库提交到远程仓库"></a>将本地仓库提交到远程仓库</h5>
      <blockquote>
<p>git push origin master</p>
</blockquote>

        <h5 id="创建分支并切换过去">
          <a href="#创建分支并切换过去" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建分支并切换过去" class="headerlink" title="创建分支并切换过去"></a>创建分支并切换过去</h5>
      <blockquote>
<p>git checkout -b 分支名</p>
</blockquote>

        <h5 id="切换回主分支">
          <a href="#切换回主分支" class="heading-link"><i class="fas fa-link"></i></a><a href="#切换回主分支" class="headerlink" title="切换回主分支"></a>切换回主分支</h5>
      <blockquote>
<p>git checkout master</p>
</blockquote>

        <h5 id="删除分支">
          <a href="#删除分支" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5>
      <blockquote>
<p>git branch  -d 分支名</p>
</blockquote>

        <h5 id="更新本地仓库">
          <a href="#更新本地仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#更新本地仓库" class="headerlink" title="更新本地仓库"></a>更新本地仓库</h5>
      <blockquote>
<p>git pull</p>
</blockquote>

        <h5 id="将分支推送到远程仓库">
          <a href="#将分支推送到远程仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#将分支推送到远程仓库" class="headerlink" title="将分支推送到远程仓库"></a>将分支推送到远程仓库</h5>
      <blockquote>
<p>git push origin 分支名</p>
</blockquote>

        <h5 id="查看仓库当前的状态，显示有变更的文件。">
          <a href="#查看仓库当前的状态，显示有变更的文件。" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看仓库当前的状态，显示有变更的文件。" class="headerlink" title="查看仓库当前的状态，显示有变更的文件。"></a>查看仓库当前的状态，显示有变更的文件。</h5>
      <blockquote>
<p>git status</p>
</blockquote>
]]></content>
      <categories>
        <category>代码库</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>周期总结</title>
    <url>/id_30/</url>
    <content><![CDATA[<h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <p>转眼一个周期过去了，学了很多零碎的知识点。有遇到困难，有得到解惑。</p>
<a id="more"></a>

<p>day01: 在vue中使用ant_design<br>ant_design+vue官方文档：<span class="exturl"><a class="exturl__link" href="https://antdv.com/docs/vue/introduce-cn/">https://antdv.com/docs/vue/introduce-cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>day02: IT新闻资讯<br>网址: <span class="exturl"><a class="exturl__link" href="https://www.cnbeta.com/">https://www.cnbeta.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>day03: redis实现输入密码错误五次封禁账号<br>移步: <a href="https://www.hr915.xyz/id_20/">https://www.hr915.xyz/id_20/</a></p>
<p>day04: httpx编写测试脚本<br>移步: <a href="https://www.hr915.xyz/id_6/">https://www.hr915.xyz/id_6/</a></p>
<p>day05: 异步任务队列<br>移步: <a href="https://www.hr915.xyz/id_19/">https://www.hr915.xyz/id_19/</a></p>
<p>day06: 加权队列<br>移步: <a href="https://www.hr915.xyz/id_21/">https://www.hr915.xyz/id_21/</a></p>
<p>day07: 异步消费<br>移步: <a href="https://www.hr915.xyz/id_22/">https://www.hr915.xyz/id_22/</a></p>
<p>day08: 权限模型</p>
<p>day09: 三方登录<br>移步: <a href="https://www.hr915.xyz/id_13/">https://www.hr915.xyz/id_13/</a></p>
<p>day10: 位运算<br>移步: <a href="https://www.hr915.xyz/id_23/">https://www.hr915.xyz/id_23/</a></p>
<p>day11: 工单分类</p>
<p>day12: Mongodb<br>移步: <a href="https://www.hr915.xyz/id_24/">https://www.hr915.xyz/id_24/</a></p>
<p>day13: 审批流程</p>
<p>day14: 栈的使用<br>移步: <a href="https://www.hr915.xyz/id_25/">https://www.hr915.xyz/id_25/</a></p>
<p>day15: 设计模式<br>移步: <a href="https://www.hr915.xyz/id_26/">https://www.hr915.xyz/id_26/</a></p>
<p>day16: 消息盒子</p>
<p>day17: websocket<br>移步: <a href="https://www.hr915.xyz/id_10/">https://www.hr915.xyz/id_10/</a></p>
<p>day18: 客服系统</p>
<p>day19: 部署</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>axios封装</title>
    <url>/id_31/</url>
    <content><![CDATA[<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。<br>他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御CSRF等。<br>axios文档：<span class="exturl"><a class="exturl__link" href="https://www.npmjs.com/package/axios">https://www.npmjs.com/package/axios</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>


        <h4 id="安装">
          <a href="#安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装" class="headerlink" title="安装"></a>安装</h4>
      <figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="引入">
          <a href="#引入" class="heading-link"><i class="fas fa-link"></i></a><a href="#引入" class="headerlink" title="引入"></a>引入</h4>
      <p>通常我们会在src中，新建一个http文件夹，里边新建index.js和api.js文件，index.js文件用来封装我们的axios，api.js用来统一管理我们的接口</p>
<hr>
<p>我们需要在index.js中做如下操作：</p>
<ul>
<li>首先需要引入axios</li>
</ul>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="comment">// 设置默认请求地址</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://127.0.0.1:8000/'</span></span><br><span class="line"><span class="comment">// 设置请求超时时限</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span></span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li><p>请求拦截<br>我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？<br>比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。<br>这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。</p>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器 当请求被发送之前进行我们想要的操作</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> {</span><br><span class="line">  <span class="comment">// 从localStorage中获取token</span></span><br><span class="line">  <span class="keyword">let</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">'token'</span>);</span><br><span class="line">  <span class="comment">// 如果有token, 就把token设置到请求头中Authorization字段中</span></span><br><span class="line">  <span class="keyword">if</span> (token) {</span><br><span class="line">    axios.defaults.headers[<span class="string">'Authorization'</span>] = token</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// token &amp;&amp; (config.headers.Authorization = token);</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">}, <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></div></figure></li>
<li><p>响应拦截<br>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。<br>例如下面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，<br>其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。</p>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器（当后端返回数据的时候进行拦截）</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">  <span class="comment">// 当响应码是 2xx 的情况, 进入这里</span></span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="keyword">return</span> response.data;</span><br><span class="line">}, <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(error.response)</span><br><span class="line">  <span class="comment">// 当响应码不是 2xx 的情况, 进入这里</span></span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="keyword">return</span> error</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></div></figure></li>
<li><p>根据上面封装好的axios对象，封装 get、post、put、delete请求</p>
<ul>
<li>封装get方法,对应get请求<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, params, headers</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    axios.get(url, {params, headers}).then(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">      resolve(res)</span><br><span class="line">    }).catch(<span class="function"><span class="params">err</span> =&gt;</span> {</span><br><span class="line">      reject(err)</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>封装post方法,对应post请求<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, params</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    axios.post(url, params).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">      resolve(res)</span><br><span class="line">    }).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// debugger</span></span><br><span class="line">      reject(err)</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>封装put方法,对应put请求<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">url, params, headers</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    axios.put(url, params, headers).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">      resolve(res)</span><br><span class="line">    }).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// debugger</span></span><br><span class="line">      reject(err)</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>封装delete方法,对应delete请求<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">url, params, headers</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    axios.delete(url, {<span class="attr">data</span>: params, headers}).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">      resolve(res)</span><br><span class="line">    }).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// debugger</span></span><br><span class="line">      reject(err)</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
</li>
</ul>
</li>
</ul>
<hr>

        <h4 id="到这里axios的封装基本就完成了，下面还有api的统一管理">
          <a href="#到这里axios的封装基本就完成了，下面还有api的统一管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#到这里axios的封装基本就完成了，下面还有api的统一管理" class="headerlink" title="到这里axios的封装基本就完成了，下面还有api的统一管理"></a>到这里axios的封装基本就完成了，下面还有api的统一管理</h4>
      <ul>
<li>首先在api.js里面导入我们封装的方法<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> {get, post, put, del} <span class="keyword">from</span> <span class="string">'./index'</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>现在比如我们要注册一个账号，是post请求,我们可以再api中这样封装<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> signUp = <span class="function"><span class="params">parameter</span> =&gt;</span> {</span><br><span class="line">  <span class="comment">// 注册</span></span><br><span class="line">  <span class="keyword">return</span> post(</span><br><span class="line">    <span class="comment">// baseURL后拼接的路由 </span></span><br><span class="line">    <span class="string">'signup/'</span>,</span><br><span class="line">    <span class="comment">// post携带的data数据</span></span><br><span class="line">    parameter</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>然后我们可以在页面中这样调用我们的api接口<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">signUp</span>(<span class="params"></span>)</span>{</span><br><span class="line">      <span class="keyword">let</span> params = {</span><br><span class="line">        <span class="string">"email"</span>: <span class="built_in">this</span>.signup_email,</span><br><span class="line">        <span class="string">"username"</span>: <span class="built_in">this</span>.signup_username,</span><br><span class="line">        <span class="string">"phone"</span>: <span class="built_in">this</span>.signup_phone,</span><br><span class="line">        <span class="string">'password'</span>: <span class="built_in">this</span>.signup_password,</span><br><span class="line">      }</span><br><span class="line">      signUp(params).then(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">if</span> (res.code == <span class="number">10004</span>) {</span><br><span class="line">          <span class="built_in">this</span>.signup_errors = res.msg  <span class="comment">//10004注册失败</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.signup_errors.email[<span class="number">0</span>])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (res.code == <span class="number">10001</span>) {</span><br><span class="line">          <span class="built_in">this</span>.signup_errors = <span class="string">''</span>  <span class="comment">//初始化错误信息</span></span><br><span class="line">          <span class="built_in">this</span>.message = res.msg  <span class="comment">//10001注册成功</span></span><br><span class="line">        }</span><br><span class="line">      }).catch(<span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>其他的api接口，就在api.js中继续往下面扩展就可以了,但是一定要注意写好注释
        <h4 id="OK-这样一个axios封装就做好啦">
          <a href="#OK-这样一个axios封装就做好啦" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-这样一个axios封装就做好啦" class="headerlink" title="OK 这样一个axios封装就做好啦"></a>OK 这样一个axios封装就做好啦</h4>
      </li>
</ul>
<p>vue-git地址：<span class="exturl"><a class="exturl__link" href="https://gitee.com/before-l/vue-project.git">https://gitee.com/before-l/vue-project.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Git分支</title>
    <url>/id_33/</url>
    <content><![CDATA[<h3 id="Git分支">
          <a href="#Git分支" class="heading-link"><i class="fas fa-link"></i></a><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3>
      
        <h4 id="什么是分支">
          <a href="#什么是分支" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是分支" class="headerlink" title="什么是分支"></a>什么是分支</h4>
      <p>分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。<br>简单理解：可以理解为复仇者联盟里面的多元宇宙，各个宇宙之间互不影响，到某一时间点会合并</p>
<a id="more"></a>

        <h4 id="好处">
          <a href="#好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#好处" class="headerlink" title="好处"></a>好处</h4>
      <p>为了不受其他开发人员的影响，可以在主分支上建立自己专用的分支。<br>完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。</p>

        <h4 id="操作分支的简单命令">
          <a href="#操作分支的简单命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作分支的简单命令" class="headerlink" title="操作分支的简单命令"></a>操作分支的简单命令</h4>
      <p>查看所有分支</p>
<blockquote>
<p>git branch -a</p>
</blockquote>
<p>查看云端分支</p>
<blockquote>
<p>git branch -r</p>
</blockquote>
<p>拉取云端代码or分支</p>
<blockquote>
<p>git pull</p>
</blockquote>
<p>创建分支</p>
<blockquote>
<p>git branch 分支名</p>
</blockquote>
<p>切换分支</p>
<blockquote>
<p>git checkout -b 或者git switch -c </p>
</blockquote>
<p>合并某分支到当前分支</p>
<blockquote>
<p>git merge 分支名 或者 git rebase 分支名</p>
<p>merge可以保留所有提交，方便回滚，但不方便查看提交日志</p>
<p>rebase 只保留主历史，线性历史，便于查看，但每次都会把平行的历史给抹掉</p>
</blockquote>
<p>删除分支</p>
<blockquote>
<p>git branch -d</p>
</blockquote>
<p>查看提交日志</p>
<blockquote>
<p>git log</p>
</blockquote>
<p>代码回退</p>
<blockquote>
<p>git reset –hard 提交ID</p>
</blockquote>
<p>回退完需要提交到线上 但是只需要提交头部 </p>
<blockquote>
<p>git push origin HEAD –force</p>
<p>// force强制提交,注意：不能跳分支回退</p>
</blockquote>
<p>参考链接：<span class="exturl"><a class="exturl__link" href="https://backlog.com/git-tutorial/cn/">https://backlog.com/git-tutorial/cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>代码库</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉树</title>
    <url>/id_34/</url>
    <content><![CDATA[<h3 id="数据结构">
          <a href="#数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>
      <p>简单的三种数据结构：</p>
<p><img src="/id_34/1.png" alt="数据结构"></p>
<a id="more"></a>
<p>树：由一个根节点分出许多子节点，最终的节点叫做叶子节点</p>
<p>二叉树：每一个节点都会生出两个子节点(左节点or右节点)，最终的节点叫做叶子节点</p>
<p>栈和队列想查询某个元素只有遍历查询，而树每个节点之间都有关联，便于高效查询</p>
<p>查询效率第一位的时候需要用到树结构</p>

        <h4 id="遍历方式：">
          <a href="#遍历方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历方式：" class="headerlink" title="遍历方式："></a>遍历方式：</h4>
      <p>树遍历的三种方式：前序遍历，中序遍历，后序遍历</p>
<ul>
<li>前序遍历 从根节点开始输出—&gt;左节点输出，继续向下左节点输出，直到叶子节点—&gt;右节点输出—&gt;   简单来说: 根—&gt;左—&gt;右</li>
<li>中序遍历 先找左子树，找到叶子结点输出—&gt;上一级输出—-&gt;右节点的左叶子结点输出—&gt;上一级输出—右节点的左叶子节点输出—&gt;  简单来说: 左—&gt;根—&gt;右</li>
<li>后序遍历 从子节点的左/右叶子节点，开始输出—&gt;右节点输出—&gt;上级节点—&gt;   简单来说: 左—&gt;右—&gt;根</li>
</ul>
<p>举个例子:<br><img src="/id_34/%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86.png" alt="数据结构"></p>

        <h4 id="代码实现">
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.data = <span class="literal">None</span></span><br><span class="line">        self.lis = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preface</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">'''先序'''</span></span><br><span class="line">        self.lis.append(node.data)</span><br><span class="line">        <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">            self.preface(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">            self.preface(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleorder</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">'''中序'''</span></span><br><span class="line">        <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">            self.middleorder(node.left)</span><br><span class="line"></span><br><span class="line">        self.lis.append(node.data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">            self.middleorder(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postscript</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">'''后序'''</span></span><br><span class="line">        <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">            self.postscript(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">            self.postscript(node.right)</span><br><span class="line"></span><br><span class="line">        self.lis.append(node.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, node, lis, data</span>):</span></span><br><span class="line">        <span class="string">'''查找'''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left == <span class="literal">None</span>:</span><br><span class="line">            lis = self.search(node.left, lis, data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            lis = self.search(node.right, lis, data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lis != []:</span><br><span class="line">            <span class="comment"># 判断当前节点是否在查询节点的线上</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> lis[-<span class="number">1</span>] == node.left.data:</span><br><span class="line">                    lis.append(node.data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> lis[-<span class="number">1</span>] == node.right.data:</span><br><span class="line">                    lis.append(node.data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.data == data:</span><br><span class="line">            lis.append(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = Tree()</span><br><span class="line"></span><br><span class="line">    root.data = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">    root.left = Tree()</span><br><span class="line">    root.left.data = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">    root.right = Tree()</span><br><span class="line">    root.right.data = <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">    root.left.left = Tree()</span><br><span class="line">    root.left.left.data = <span class="string">'4'</span></span><br><span class="line"></span><br><span class="line">    root.left.right = Tree()</span><br><span class="line">    root.left.right.data = <span class="string">'5'</span></span><br><span class="line"></span><br><span class="line">    root.right.left = Tree()</span><br><span class="line">    root.right.left.data = <span class="string">'6'</span></span><br><span class="line"></span><br><span class="line">    root.right.right = Tree()</span><br><span class="line">    root.right.right.data = <span class="string">'7'</span></span><br><span class="line"></span><br><span class="line">    root.left.left.left = Tree()</span><br><span class="line">    root.left.left.left.data = <span class="string">'8'</span></span><br><span class="line"></span><br><span class="line">    root.left.right.left = Tree()</span><br><span class="line">    root.left.right.left.data = <span class="string">'9'</span></span><br><span class="line"></span><br><span class="line">    root.right.left.right = Tree()</span><br><span class="line">    root.right.left.right.data = <span class="string">'10'</span></span><br><span class="line"></span><br><span class="line">    root.right.right.right = Tree()</span><br><span class="line">    root.right.right.right.data = <span class="string">'11'</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'先序:'</span>)</span><br><span class="line">    root.lis = []</span><br><span class="line">    root.preface(root)</span><br><span class="line">    print(root.lis)</span><br><span class="line">    print(<span class="string">'中序:'</span>)</span><br><span class="line">    root.lis = []</span><br><span class="line">    root.middleorder(root)</span><br><span class="line">    print(root.lis)</span><br><span class="line">    print(<span class="string">'后序:'</span>)</span><br><span class="line">    root.lis = []</span><br><span class="line">    root.postscript(root)</span><br><span class="line">    print(root.lis)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful</title>
    <url>/id_36/</url>
    <content><![CDATA[<h3 id="Restful：">
          <a href="#Restful：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Restful：" class="headerlink" title="Restful："></a>Restful：</h3>
      <p>一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<a id="more"></a>
<p>这么理解试试看，也就是你听过建筑的复古风格，欧美风格之类的么，大体就是一个意思。如果你盖个别墅不按设计风格走，直接以小茅屋的形式，没有属于任何风格它也能盖成不是，这就是我们平时开发API不按RESTFUL风格也可以是一个道理。REST 指的是一组架构约束条件和原则，满足这些约束条件和原则的应用程序或设计就是RESTful。</p>

        <h4 id="Restful发展历程：">
          <a href="#Restful发展历程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Restful发展历程：" class="headerlink" title="Restful发展历程："></a>Restful发展历程：</h4>
      <p>详细发展历程：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/a78270528/article/details/78469758">https://blog.csdn.net/a78270528/article/details/78469758</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Restful风格==面向过程—&gt;面向资源—&gt;面向标签—&gt;面向文档</p>
<p>面向过程==想起一出是一出，只要有功能就写新接口</p>
<p>面向资源==封装单个接口，添加一个接口，删除一个接口，修改一个接口，多重逻辑需要多个if-else</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method ==POST:</span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">elif</span> request.method==GET:</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></div></figure>
<p>面向标签==封装单个接口，通过method进行语义化操作 post/put/delete/get</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>面向文档==具备面向标签的功能语义化，在返回响应的时候告诉客户还可以做什么操作</p>
<ul>
<li>说这么多，到底restful是什么？
        <h4 id="接口规范">
          <a href="#接口规范" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h4>
      </li>
</ul>
<ol>
<li><p>统一资源接口<br> RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p>
</li>
<li><p>URL中只使用名词来指定资源，原则上不使用动词</p>
</li>
<li><p>用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转<br> GET 用来获取资源，<br> POST 用来新建资源（也可以用于更新资源），<br> PUT 用来更新资源，<br> DELETE 用来删除资源。  </p>
</li>
<li><p>Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（on-wire data compression）。</p>
</li>
<li><p>用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</p>
</li>
</ol>

        <h4 id="一些其他规范：">
          <a href="#一些其他规范：" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些其他规范：" class="headerlink" title="一些其他规范："></a>一些其他规范：</h4>
      <p>规则1：URI结尾不应包含（/）<br>规则2：正斜杠分隔符（/）必须用来指示层级关系<br>规则3：应使用连字符（ - ）来提高URI的可读性<br>规则4：不得在URI中使用下划线（_）<br>规则5：URI路径中全都使用小写字母</p>
]]></content>
      <tags>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenLdap</title>
    <url>/id_35/</url>
    <content><![CDATA[<h4 id="什么是OpenLdap">
          <a href="#什么是OpenLdap" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是OpenLdap" class="headerlink" title="什么是OpenLdap:"></a>什么是OpenLdap:</h4>
      <p>轻型目录访问协议（英文： LightweightDirectoryAccessProtocol，缩写： LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。OpenLDAP是轻型目录访问协议（ LightweightDirectoryAccessProtocol， LDAP）的自由和开源的实现，在其 OpenLDAP许可证下发行，并已经被包含在众多流行的 Linux发行版中。</p>
<a id="more"></a>

        <h4 id="为什么要用OpenLdap">
          <a href="#为什么要用OpenLdap" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要用OpenLdap" class="headerlink" title="为什么要用OpenLdap:"></a>为什么要用OpenLdap:</h4>
      <p>可以这样讲：市面上只要你能够想像得到的所有工具软件，全部都支持 LDAP协议。<br>比如说你公司要安装一个项目管理工具，那么这个工具几乎必然支持 LDAP协议，你公司要安装一个 bug管理工具，这工具必然也支持 LDAP协议，你公司要安装一套软件版本管理工具，这工具也必然支持 LDAP协议。 LDAP协议的好处就是你公司的所有员工在所有这些工具里共享同一套用户名和密码，来人的时候新增一个用户就能自动访问所有系统，走人的时候一键删除就取消了他对所有系统的访问权限，这就是 LDAP</p>

        <h4 id="相关概念-属性">
          <a href="#相关概念-属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关概念-属性" class="headerlink" title="相关概念(属性):"></a>相关概念(属性):</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">英文简称</th>
<th align="left">英文全称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DC</td>
<td align="left">Domain Component</td>
<td align="left">域名的部分，其格式是将完整的域名分成几部分，如域名为xxxx.com变成dc=xxxx,dc=com。简单理解把它理解成域名标识即可。</td>
</tr>
<tr>
<td align="left">OU</td>
<td align="left">Organization Unit</td>
<td align="left">组织单位，组织单位可以包含其他各种对象，如“开发组”（一条记录的所属组织）。简单理解把他理解成公司的组织和部门：ou=开发一组，ou=技术研发部门</td>
</tr>
<tr>
<td align="left">UID</td>
<td align="left">User Id</td>
<td align="left">用户ID zhangsan（一条记录的ID）</td>
</tr>
<tr>
<td align="left">DN</td>
<td align="left">Distinguished Name</td>
<td align="left">“uid=zhangsan,ou=开发一组，ou=技术研发部门,dc=xxxx,dc=com”，一条记录的位置（唯一） DN的元素包含UID（或CN) + OU + DC</td>
</tr>
<tr>
<td align="left">CN</td>
<td align="left">Common Name</td>
<td align="left">公共名称，如“张三”（一条记录的名称）。简单理解用于描述UID的</td>
</tr>
<tr>
<td align="left">rdn</td>
<td align="left">Relative dn</td>
<td align="left">相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid=zhangsan”或“cn= 张三”</td>
</tr>
<tr>
<td align="left">SN</td>
<td align="left">Surname</td>
<td align="left">姓，如“张”</td>
</tr>
</tbody></table></div>

        <h5 id="DN">
          <a href="#DN" class="heading-link"><i class="fas fa-link"></i></a><a href="#DN" class="headerlink" title="DN:"></a>DN:</h5>
      <p>LDAP连接服务器的连接字串格式为：ldap://servername/DN  </p>
<p>其中DN有三个属性，分别是CN,OU,DC  </p>
<p>CN, OU, DC 都是 LDAP 连接服务器的端字符串中的区别名称（DN, distinguished  name） </p>
<p>LDAP是一种通讯协议，如同HTTP是一种协议一样的！ </p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>OpenLdap</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort和Sorted区别</title>
    <url>/id_38/</url>
    <content><![CDATA[<h4 id="引入">
          <a href="#引入" class="heading-link"><i class="fas fa-link"></i></a><a href="#引入" class="headerlink" title="引入"></a>引入</h4>
      <p>我们需要对List进行排序，Python提供了两个方法<br>对给定的List L进行排序，<br>方法1.用List的成员函数sort进行排序<br>方法2.用内建函数sorted进行排序（从python 2.4开始）</p>
<a id="more"></a>

        <h4 id="语法：">
          <a href="#语法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4>
      <p>sort函数定义：sort(cmp=None, key=None, reverse=False)<br>sorted函数定义：sorted(iterable, cmp=None, key=None, reverse=False)</p>
<p>参数解析：<br>iterable：是可迭代类型;<br>cmp：用于比较的函数（大于时返回1，小于时返回-1，等于时返回0），比较什么由key决定,有默认值，迭代集合中的一项;<br>key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;<br>reverse：排序规则. reverse = True 或者 reverse = False，有默认值。</p>

        <h4 id="区别">
          <a href="#区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#区别" class="headerlink" title="区别:"></a>区别:</h4>
      <ol>
<li>sort( )函数时对已存在的列表进行操作，调用其没有返回值；<br>而sorted( )函数是返回一个新的list,不在原来的list上进行操作，调用其返回一个排好序的list。</li>
<li>sorted()不会改变原来的list，而是会返回一个新的已经排序好的list<br>list.sort()方法仅仅被list所定义，sorted()可用于任何一个可迭代对象</li>
</ol>

        <h4 id="举例说明：">
          <a href="#举例说明：" class="heading-link"><i class="fas fa-link"></i></a><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4>
      <p>示例1:</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">a = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line"> </span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">d = <span class="built_in">sorted</span>(c)</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line">print(c)</span><br></pre></td></tr></tbody></table></div></figure>
<p>得：</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br></pre></td></tr></tbody></table></div></figure>
<p>示例1是采用函数默认的设置</p>
<ul>
<li>对于排序参数设置，主要有以下两种：基于key；基于reverse。<br>示例2: 基于key和reverse</li>
</ul>
<p>1.reverse实现降序排序，需要提供一个布尔值，默认为False（升序排列）。<br>2.key在使用时必须提供一个排序过程总调用的函数：</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">alist  =  [( <span class="string">'2'</span> ,  <span class="string">'3'</span> ,  <span class="string">'10'</span> ), ( <span class="string">'1'</span> ,  <span class="string">'2'</span> ,  <span class="string">'3'</span> ), ( <span class="string">'5'</span> ,  <span class="string">'6'</span> ,  <span class="string">'7'</span> ), ( <span class="string">'2'</span> ,  <span class="string">'5'</span> ,  <span class="string">'10'</span> ), ( <span class="string">'2'</span> ,  <span class="string">'4'</span> ,  <span class="string">'10'</span> )]</span><br><span class="line"><span class="comment"># 多级排序，先按照第3个元素排序，然后按照第2个元素排序：</span></span><br><span class="line"><span class="comment"># reverse = False 降序</span></span><br><span class="line">print(<span class="built_in">sorted</span>(alist, key=<span class="keyword">lambda</span>  x:( <span class="built_in">int</span> (x[ <span class="number">2</span> ]),<span class="built_in">int</span> (x[ <span class="number">1</span> ])),reverse  =  <span class="literal">False</span> )) </span><br><span class="line"><span class="comment"># reverse = False 升序</span></span><br><span class="line">alist.sort(key=<span class="keyword">lambda</span>  x:( <span class="built_in">int</span> (x[ <span class="number">2</span> ]),<span class="built_in">int</span> (x[ <span class="number">1</span> ])),reverse  =  <span class="literal">True</span> )</span><br><span class="line">print(alist)</span><br></pre></td></tr></tbody></table></div></figure>
<p>得：</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">[(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>), (<span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>), (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'10'</span>)]</span><br><span class="line">[(<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'10'</span>), (<span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>)]```</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="结论：">
          <a href="#结论：" class="heading-link"><i class="fas fa-link"></i></a><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5>
      <p>1、函数sorted()不改变原来的list，而是返回一个新的排好序的list。<br>2、key可以采用lambda表达式<br>3、排序的key是函数自己选择；采用key是确定排序的key，排序方式是函数自己选择。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>内置方法</tag>
      </tags>
  </entry>
  <entry>
    <title>集合(SET)</title>
    <url>/id_39/</url>
    <content><![CDATA[<h3 id="集合">
          <a href="#集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合" class="headerlink" title="集合"></a>集合</h3>
      <p>集合（set）是一个无序的不重复元素序列。一般用于去重。<br>当元素的顺序性没有唯一性重要的时候，使用到SET去重</p>
<a id="more"></a>

<p>集合又分为可变集合和不可变集合</p>
<p>可变集合(set)：通过add等方法可以动态修改set中的内容</p>
<p>不可变集合(frozenset)：顾名思义，他的元素是不可变的</p>
<blockquote>
<p>frozenset()是一个函数，会返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p>
</blockquote>

        <h4 id="特点">
          <a href="#特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4>
      <ol>
<li>不同元素组成（元素不能重复）</li>
<li>无序（集合元素的顺序和定义、添加的顺序不一致）</li>
<li>集合中的元素必须是不可变类型</li>
</ol>

        <h4 id="底层实现">
          <a href="#底层实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 集合SET去重操作原理: 必须要有另外一个容器作比对，</span></span><br><span class="line"><span class="comment"># 比如每样鱼我要来一条，那么我旁边就需要有一个新的鱼缸，然后把挑选出来的鱼放进新鱼缸中，捞第二条的时候用眼睛和第一条作比对</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">mylist = []</span><br><span class="line"></span><br><span class="line">[mylist.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> mylist]</span><br><span class="line"></span><br><span class="line">print(mylist)</span><br></pre></td></tr></tbody></table></div></figure>
<p>延伸一下append的底层原理：</p>
<blockquote>
<p>append其实是用到了队列,先进先出的概念</p>
<p>跟append一起的还有insert，两个的差别在于一个从头部插入，一个从尾部插入</p>
</blockquote>

        <h4 id="集合的创建：">
          <a href="#集合的创建：" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合的创建：" class="headerlink" title="集合的创建："></a>集合的创建：</h4>
      <p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集合</span></span><br><span class="line">parame = {<span class="number">1</span>,<span class="number">2</span>}</span><br><span class="line">print(<span class="built_in">type</span>(parame))</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">a = <span class="string">'hello'</span></span><br><span class="line">print(<span class="built_in">set</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建空集合</span></span><br><span class="line">myset = <span class="built_in">set</span>()</span><br><span class="line">print(<span class="built_in">type</span>(myset))</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="集合常用方法">
          <a href="#集合常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-add.html">add()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">为集合添加元素</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">移除集合中的所有元素</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">拷贝一个集合</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">返回多个集合的差集</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">删除集合中指定的元素</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">返回集合的交集</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">返回集合的交集。</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">随机移除元素</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">移除指定元素</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-union.html">union()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">返回两个集合的并集</td>
</tr>
<tr>
<td align="left"><span class="exturl"><a class="exturl__link" href="https://www.runoob.com/python3/ref-set-update.html">update()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></td>
<td align="left">给集合添加元素</td>
</tr>
</tbody></table></div>

        <h5 id="添加元素">
          <a href="#添加元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 向一个空集合中添加元素</span></span><br><span class="line">myset = <span class="built_in">set</span>()</span><br><span class="line">myset.add(<span class="string">'hello'</span>)</span><br><span class="line">print(myset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># update可以添加多个参数，可以是列表，元组，字典等，参数用逗号隔开</span></span><br><span class="line">myset = <span class="built_in">set</span>()</span><br><span class="line">myset.update(<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>],{<span class="number">3</span>:<span class="number">4</span>},(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">print(myset)</span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="移除元素">
          <a href="#移除元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 随机删除一个元素  pop</span></span><br><span class="line">parame = {<span class="number">1</span>,<span class="number">2</span>}</span><br><span class="line">parame.pop()</span><br><span class="line">print(parame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定元素 remove,元素不存在报错</span></span><br><span class="line">myset = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">myset.remove(<span class="number">4</span>)</span><br><span class="line">print(myset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定元素 discard,元素不存在不会报错</span></span><br><span class="line">myset = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">myset.discard(<span class="number">7</span>)</span><br><span class="line">print(myset)</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="集合的运算符">
          <a href="#集合的运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合的运算符" class="headerlink" title="集合的运算符"></a>集合的运算符</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>-</strong></td>
<td align="left">集合a中包含而集合b中不包含的元素</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">集合a或b中包含的所有元素</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">集合a和b中都包含了的元素</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">不同时包含于a和b的元素</td>
</tr>
</tbody></table></div>

        <h5 id="举例">
          <a href="#举例" class="heading-link"><i class="fas fa-link"></i></a><a href="#举例" class="headerlink" title="举例"></a>举例</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">'123456'</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">'456789'</span>)</span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="集合a中包含而集合b中不包含的元素">
          <a href="#集合a中包含而集合b中不包含的元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合a中包含而集合b中不包含的元素" class="headerlink" title="集合a中包含而集合b中不包含的元素"></a>集合a中包含而集合b中不包含的元素</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">print(a - b)</span><br><span class="line"><span class="comment"># {'1', '2', '3'}</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="集合a或b中包含的所有元素">
          <a href="#集合a或b中包含的所有元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合a或b中包含的所有元素" class="headerlink" title="集合a或b中包含的所有元素"></a>集合a或b中包含的所有元素</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">print(a | b)</span><br><span class="line"><span class="comment"># {'1', '4', '5', '2', '8', '3', '6', '7', '9'}</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="集合a和b中都包含了的元素">
          <a href="#集合a和b中都包含了的元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合a和b中都包含了的元素" class="headerlink" title="集合a和b中都包含了的元素"></a>集合a和b中都包含了的元素</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">print(a &amp; b)</span><br><span class="line"><span class="comment"># {'4', '5', '6'}</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="不同时包含于a和b的元素">
          <a href="#不同时包含于a和b的元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同时包含于a和b的元素" class="headerlink" title="不同时包含于a和b的元素"></a>不同时包含于a和b的元素</h5>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">print(a ^ b)</span><br><span class="line"><span class="comment"># {'8', '3', '7', '9', '1', '2'}</span></span><br></pre></td></tr></tbody></table></div></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>类型</tag>
      </tags>
  </entry>
  <entry>
    <title>docker操作 容器、镜像 &amp;&amp; dockerfile</title>
    <url>/id_4/</url>
    <content><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<a id="more"></a>


        <h3 id="Docker-的优点">
          <a href="#Docker-的优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3>
      <ul>
<li>  快速部署：短时间内可以部署成百上千个应用，更快速交付到线上</li>
<li>  高效虚拟化：不需要额外hypervisor支持，基于linux内核实现应用虚拟化，相比虚拟机大幅提高性能和效率</li>
<li>  节省开支：提高服务器利用率，降低IT支出</li>
<li>  简化配置：将运行环境打包保存至容器，使用时直接启动即可</li>
<li>  环境统一：将开发，测试，生产的应用运行环境进行标准化和统一，减少环境不一样带来的各种问题</li>
<li>  快速迁移和扩展：可实现跨平台运行在物理机、虚拟机、公有云等环境，良好的兼容性可以方便将应用从A宿主机迁移到B宿主机，甚至是A平台迁移到B平台</li>
</ul>

        <h3 id="Docker-包括三个基本概念">
          <a href="#Docker-包括三个基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker-包括三个基本概念" class="headerlink" title="Docker 包括三个基本概念:"></a>Docker 包括三个基本概念:</h3>
      <ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。<br>Docker 容器通过 Docker 镜像来创建。<br>容器与镜像的关系类似于面向对象编程中的对象(容器)与类(镜像)。</li>
</ul>

        <h3 id="Docker安装">
          <a href="#Docker安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3>
      
        <h4 id="安装Docker-CentOS">
          <a href="#安装Docker-CentOS" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装Docker-CentOS" class="headerlink" title="安装Docker - CentOS"></a>安装Docker - CentOS</h4>
      <ul>
<li>Docker 软件包和依赖包已经包含在默认的 CentOS-Extras 软件源里，安装命令如下：<figure class="highlight shell"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install docker</span><br></pre></td></tr></tbody></table></div></figure>
<img src="/id_4/01.png" alt="安装"></li>
<li>安装成功<br><img src="/id_4/02.png" alt="安装成功"></li>
<li>启动Docker后台服务<figure class="highlight shell"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></tbody></table></div></figure>
<img src="/id_4/03.png" alt="启动服务"></li>
<li>测试运行hello-world<figure class="highlight shell"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></tbody></table></div></figure>
<img src="/id_4/04.png" alt="测试"><blockquote>
<p>因为本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行</p>
</blockquote>
</li>
</ul>

        <h3 id="Docker使用">
          <a href="#Docker使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h3>
      <p>Docker官网：<span class="exturl"><a class="exturl__link" href="https://www.docker.com/">https://www.docker.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="Docker镜像使用">
          <a href="#Docker镜像使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker镜像使用" class="headerlink" title="Docker镜像使用"></a>Docker镜像使用</h4>
      <ul>
<li>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。<blockquote>
<p>docker</p>
</blockquote>
</li>
</ul>
<p><img src="/id_4/05.png" alt="全部命令"><br>可以通过命令 docker command –help 更深入的了解指定的 Docker 命令使用方法。</p>
<ul>
<li><p>拉取镜像</p>
<blockquote>
<p>docker pull</p>
</blockquote>
</li>
<li><p>查看docker 镜像(首次安装完后镜像为空)</p>
<blockquote>
<p>docker images</p>
</blockquote>
</li>
<li><p>docker搜索镜像</p>
<blockquote>
<p>docker search 镜像名称(nignx) </p>
</blockquote>
</li>
<li><p>镜像导出(本地镜像导出为一个压缩文件)</p>
<blockquote>
<p>docker save 镜像名 &gt; 文件路径</p>
</blockquote>
</li>
<li><p>加载镜像(将镜像导出的压缩文件再导入)</p>
<blockquote>
<p>docker load &lt; 文件名  </p>
</blockquote>
</li>
<li><p>镜像标签(类似于起别名)</p>
<blockquote>
<p>docker tag 镜像名 镜像名:标签</p>
</blockquote>
</li>
</ul>
<p>搜索下来的镜像和Docker Hub上是一样的</p>
<ul>
<li><p>拉取镜像</p>
<ul>
<li><p>因为国内访问docker hub的速度慢  所以要使用加速服务</p>
<blockquote>
<p>使用ustc镜像加速器   进行配置</p>
<p>vi /etc/docker/daemon.json</p>
</blockquote>
</li>
<li><p>在配置文件中配置以下内容</p>
<blockquote>
<p>{</p>
<p> “registry-mirrors”: [“<a href="https://docker.mirrors.ustc.edu.cn&quot;]">https://docker.mirrors.ustc.edu.cn"]</a></p>
<p>}</p>
</blockquote>
</li>
<li><p>配置完以后重启docker</p>
<blockquote>
<p>systemctl  start  docker</p>
</blockquote>
</li>
<li><p>最后进行拉取镜像</p>
<blockquote>
<p>docker pull  镜像名称</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>查看所有镜像ID<blockquote>
<p>docker  images  -q</p>
</blockquote>
</li>
<li>删除镜像<blockquote>
<p>docker rmi  镜像名称/镜像 ID</p>
</blockquote>
</li>
</ul>

        <h4 id="Docker容器使用">
          <a href="#Docker容器使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker容器使用" class="headerlink" title="Docker容器使用"></a>Docker容器使用</h4>
      <p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<ul>
<li>获取镜像<blockquote>
<p>docker pull 镜像名</p>
</blockquote>
</li>
<li>启动容器 <blockquote>
<p>docker run 镜像名</p>
</blockquote>
</li>
<li>查看所有容器<blockquote>
<p>docker ps -a</p>
</blockquote>
</li>
<li>启动一个已经停止的容器<blockquote>
<p>docker start 容器ID</p>
</blockquote>
</li>
<li>停止容器<blockquote>
<p>docker stop 容器ID</p>
</blockquote>
</li>
<li>重启容器<blockquote>
<p>docker restart 容器ID</p>
</blockquote>
</li>
<li>删除指定的容器(只能删除关闭的容器)<blockquote>
<p>docker rm  (-rf)  容器ID<br>-rf强制删除</p>
</blockquote>
</li>
</ul>

        <h3 id="Dockerfile">
          <a href="#Dockerfile" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3>
      
        <h4 id="什么是-Dockerfile？">
          <a href="#什么是-Dockerfile？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h4>
      <p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>

        <h4 id="Dockerfile的基本结构">
          <a href="#Dockerfile的基本结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dockerfile的基本结构" class="headerlink" title="Dockerfile的基本结构"></a>Dockerfile的基本结构</h4>
      <p>Dockerfile 一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令，’#’ 为 Dockerfile 中的注释。</p>

        <h4 id="Dockerfile文件说明">
          <a href="#Dockerfile文件说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dockerfile文件说明" class="headerlink" title="Dockerfile文件说明"></a>Dockerfile文件说明</h4>
      <p>Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是FROM。一个声明以＃字符开头则被视为注释。可以在Docker文件中使用RUN，CMD，FROM，EXPOSE，ENV等指令。<br>在这里列出了一些常用的指令。</p>
<ul>
<li><p>FROM</p>
<blockquote>
<p>FROM &lt;镜像名&gt;</p>
</blockquote>
<p>  FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。<br>  FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始。<br>  FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。<br>  如果FROM语句没有指定镜像标签，则默认使用latest标签。<br>RUN 有两种使用方式</p>
</li>
<li><p>RUN</p>
<blockquote>
<p>RUN  “executable”, “param1”, “param2”</p>
</blockquote>
<p>  每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的 版本控制 。<br>  exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p>
<p>  RUN [ “echo”, “$HOME” ]<br>  这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p>
<p>  RUN [ “sh”, “-c”, “echo”, “$HOME” ]<br>  RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用–no-cache选项，即docker build –no-cache，如此便不会缓存。</p>
</li>
<li><p>CMD<br>CMD有三种使用方式</p>
<blockquote>
<p>CMD &lt;shell 命令&gt;<br>CMD [“&lt;可执行文件或命令&gt;”,”<param1>“,”<param2>“,…]<br>CMD [“<param1>“,”<param2>“,…]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</param2></param1></param2></param1></p>
</blockquote>
<p>  类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:<br>  CMD 在docker run 时运行。<br>  RUN 是在 docker build。<br>  作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。<br>  注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
</li>
<li><p>ADD</p>
<blockquote>
<p>ADD <src>… <dest></dest></src></p>
</blockquote>
<p>  ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。<br>  支持通过 Go 的正则模糊匹配，具体规则可参见  Go filepath.Match</p>
<blockquote>
<p>ADD hom* /mydir/        # adds all files starting with “hom”<br>ADD hom?.txt /mydir/    # ? is replaced with any single character</p>
</blockquote>
<p>  路径必须是绝对路径，如果 不存在，会自动创建对应目录<br>  路径必须是 Dockerfile 所在路径的相对路径<br>  如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</p>
</li>
<li><p>COPY</p>
<blockquote>
<p>COPY <src>… <dest></dest></src></p>
</blockquote>
<p>  COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。</p>
</li>
</ul>
<p>Dockerfile学习自:<span class="exturl"><a class="exturl__link" href="https://www.docker.org.cn/dockerppt/114.html">https://www.docker.org.cn/dockerppt/114.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="OK-本文到此结束">
          <a href="#OK-本文到此结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#OK-本文到此结束" class="headerlink" title="OK 本文到此结束"></a>OK 本文到此结束</h3>
      ]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/id_40/</url>
    <content><![CDATA[<h3 id="正则表达式">
          <a href="#正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式" class="headerlink" title="正则表达式:"></a>正则表达式:</h3>
      <p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。<br>Pythond 的 re 模块，它提供 Perl 风格的正则表达式模式。<br>re 模块使 Python 语言拥有全部的正则表达式功能。</p>
<a id="more"></a>        

        <h4 id="正则表达式模式">
          <a href="#正则表达式模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配字符串的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配字符串的末尾。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配0个或多个的表达式。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配1个或多个的表达式。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td align="left">re{ n}</td>
<td align="left">精确匹配 n 个前面表达式。例如，<br> <strong>o{2}</strong> 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">re{ n,}</td>
<td align="left">匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，<br>但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td>
</tr>
<tr>
<td align="left">re{ n, m}</td>
<td align="left">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td align="left">a | b</td>
<td align="left">匹配a或b</td>
</tr>
<tr>
<td align="left">(re)</td>
<td align="left">对正则表达式分组并记住匹配的文本</td>
</tr>
<tr>
<td align="left">(?= re)</td>
<td align="left">前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，<br>否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；<br>模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td align="left">(?! re)</td>
<td align="left">前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母数字及下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配非字母数字及下划线</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任意空白字符，等价于 **[ \t\n\r\f]**。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任意非空字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配任意数字，等价于 [0-9].</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配任意非数字</td>
</tr>
<tr>
<td align="left">\A</td>
<td align="left">匹配字符串开始</td>
</tr>
<tr>
<td align="left">\n, \t</td>
<td align="left">匹配一个换行符。匹配一个制表符。等</td>
</tr>
</tbody></table></div>
<p> 举几个常用的例子:</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配字符串是否以1开头以3结尾</span></span><br><span class="line">print(re.findall(<span class="string">"^1.+3$"</span>, <span class="string">'123abc123'</span>))</span><br><span class="line"><span class="comment"># 匹配字符串是否包含a-f,([a-f]{1,}相当于[a-f]+)</span></span><br><span class="line">print(re.findall(<span class="string">'[a-f]{1,}'</span>, <span class="string">'abcdefghijklmnabcdefopqrstuvwxyz'</span>))</span><br><span class="line"><span class="comment"># 匹配字符串是否不包含a-f</span></span><br><span class="line">print(re.findall(<span class="string">'[^a-f]{1,}'</span>, <span class="string">'abcdefghijklmnabcdefopqrstuvwxyz'</span>))</span><br><span class="line"><span class="comment"># 匹配字符串全是数字的子串</span></span><br><span class="line">print(re.match(<span class="string">'\d+'</span>, <span class="string">'123abc123'</span>).group())</span><br><span class="line"><span class="comment"># 查看子串的下标</span></span><br><span class="line">print(re.match(<span class="string">'\d+'</span>, <span class="string">'123abc123'</span>).span())</span><br><span class="line"><span class="comment"># 匹配字符串全是字母或下划线的子串</span></span><br><span class="line">print(re.match(<span class="string">'\w?'</span>,<span class="string">'abc123abc'</span>).group())</span><br><span class="line"><span class="comment"># 查看子串的下标</span></span><br><span class="line">print(re.match(<span class="string">'\w?'</span>,<span class="string">'abc123abc'</span>).span())</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>
<p>结果为:</p>
<blockquote>
<p>[‘123abc123’]<br>  [‘abcdef’]<br>  [‘123’, ‘123’</p>
</blockquote>

        <h4 id="元字符（Metacharacter-是拥有特殊含义的字符：">
          <a href="#元字符（Metacharacter-是拥有特殊含义的字符：" class="heading-link"><i class="fas fa-link"></i></a><a href="#元字符（Metacharacter-是拥有特殊含义的字符：" class="headerlink" title="元字符（Metacharacter)是拥有特殊含义的字符："></a>元字符（Metacharacter)是拥有特殊含义的字符：</h4>
      <p> \d 查找数字。<br> \s 查找空白字符。 </p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查找数字。</span></span><br><span class="line">print(re.findall(<span class="string">'\d'</span>, <span class="string">'123abc123'</span>))</span><br><span class="line"><span class="comment"># 查找空白字符</span></span><br><span class="line">print(re.findall(<span class="string">'\s'</span>, <span class="string">'123 abc 123'</span>))</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="Quantifiers-定义量词：">
          <a href="#Quantifiers-定义量词：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quantifiers-定义量词：" class="headerlink" title="Quantifiers 定义量词："></a>Quantifiers 定义量词：</h4>
      <p> n+ 匹配任何包含至少一个 n 的字符串。<br> n* 匹配任何包含零个或多个 n 的字符串。<br> n? 匹配任何包含零个或一个 n 的字符串。</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># n+ 匹配任何包含至少一个 n 的字符串。</span></span><br><span class="line">print(re.search(<span class="string">'\d+'</span>, <span class="string">'1abc'</span>).group())</span><br><span class="line">print(re.search(<span class="string">'\d+'</span>, <span class="string">'123abc'</span>).group())</span><br><span class="line"><span class="comment"># n* 匹配任何包含零个或多个 n 的字符串。</span></span><br><span class="line">print(re.search(<span class="string">'\d*'</span>, <span class="string">'abc'</span>).group())</span><br><span class="line">print(re.search(<span class="string">'\d*'</span>, <span class="string">'123abc'</span>).group())</span><br><span class="line"><span class="comment"># n? 匹配任何包含零个或一个 n 的字符串。</span></span><br><span class="line">print(re.search(<span class="string">'\d?'</span>, <span class="string">'abc'</span>).group())</span><br><span class="line">print(re.search(<span class="string">'\d?'</span>, <span class="string">'1abc'</span>).group())</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="re-match函数">
          <a href="#re-match函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h4>
      <p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。<br>函数语法：</p>
<blockquote>
<p>re.match(pattern, string, flags=0)</p>
</blockquote>
<pre><code>参数解析:
pattern:正则表达式
string:参与正则的字符串
flags:标志位，用于控制正则表达式的匹配方式</code></pre>
<p>我们可以使用<strong>group(num)</strong> 或 <strong>groups()</strong> 匹配对象函数来获取匹配表达式。<br>group(num=0): 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。<br>groups(): 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 案例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(re.match(<span class="string">'www'</span>, <span class="string">'www.hr915.xyz'</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line">print(re.match(<span class="string">'xyz'</span>, <span class="string">'www.hr915.xyz'</span>))         <span class="comment"># 不在起始位置匹配</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>结果为:</p>
<blockquote>
<p>(0, 3)<br>  None</p>
</blockquote>

        <h4 id="re-search方法">
          <a href="#re-search方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h4>
      <p>re.search 扫描整个字符串并返回第一个成功的匹配。匹配成功re.search方法返回一个匹配的对象，否则返回None。<br>函数语法：</p>
<blockquote>
<p>re.search(pattern, string, flags=0)</p>
</blockquote>
<pre><code>参数解析:
    pattern:正则表达式
    string:参与正则的字符串
    flags:标志位，用于控制正则表达式的匹配方式</code></pre>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 案例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(re.search(<span class="string">'www'</span>, <span class="string">'www.hr915.xyz'</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line">print(re.search(<span class="string">'xyz'</span>, <span class="string">'www.hr915.xyz'</span>).span())  <span class="comment"># 不在起始位置匹配</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>结果为:</p>
<blockquote>
<p>(0, 3)<br> (10, 13)</p>
</blockquote>

        <h4 id="re-findall方法">
          <a href="#re-findall方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#re-findall方法" class="headerlink" title="re.findall方法"></a>re.findall方法</h4>
      <p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。<br>函数语法：</p>
<blockquote>
<p>findall(string, pos, endpos)</p>
</blockquote>
<pre><code>参数解析:
    string : 待匹配的字符串。
    pos : 可选参数，指定字符串的起始位置，默认为 0。
    endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</code></pre>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 案例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r'\d+'</span>)  <span class="comment"># 查找数字</span></span><br><span class="line">result1 = pattern.findall(<span class="string">'hello 123 world 456'</span>)</span><br><span class="line">result2 = pattern.findall(<span class="string">'hello88hi123world456'</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br></pre></td></tr></tbody></table></div></figure>
<p>结果为:</p>
<blockquote>
<p>[‘123’, ‘456’]<br>[‘88’, ‘1’]</p>
</blockquote>

        <h4 id="match-amp-amp-search-amp-amp-findall-的区别">
          <a href="#match-amp-amp-search-amp-amp-findall-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#match-amp-amp-search-amp-amp-findall-的区别" class="headerlink" title="match &amp;&amp; search &amp;&amp; findall 的区别"></a>match &amp;&amp; search &amp;&amp; findall 的区别</h4>
      <ul>
<li>match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None。</li>
<li>search 扫描整个字符串并返回第一个成功的匹配。匹配成功search方法返回一个匹配的对象，否则返回None</li>
<li>findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</li>
<li>search 和 findall 是扫描整个字符串，match 是只匹配起始位置</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>PostGreSQL</title>
    <url>/id_41/</url>
    <content><![CDATA[<p>最近“全栈数据库”的概念甚嚣尘上，主角就是PostgreSQL，它最近这几年的技术发展不可谓不猛，覆盖OLTP、OLAP、NoSQL、搜索、图像等应用场景，实实在在的全栈性发展。帮助公司解决了数据孤岛、数据平台多、同步一致性、延迟，软硬件成本增加等业务痛点，在互联网、金融、物联网、传统企业等领域得到了广泛的应用。PostgreSQL的应用场景丰富，不亚于商用数据库Oracle，常被业界称为“开源界的Oracle”。</p>
<a id="more"></a>       
<p>至于Mysql大家都很熟悉，很多公司因为人才储备和数据量大的原因，一般是Hadoop+Mysql的模式，Hadoop计算大量原始数据，然后按维度汇总后的展示数据存储在Mysql上，但是Mysql也有很多的“坑”：比如著名的Emoji表情坑，由此引申出来的utf8mb4的坑（隐式类型转换陷阱），性能低到发指的悲观锁机制，不支持多表单序列中取 id，不支持over子句，几乎没有性能可言的子查询…有点罄竹难书的意思，更多的“罪行”详见：见鬼的选择：Mysql。而这些问题，在PostgreSQL中得到了改善，本次我们在Win10平台利用Docker安装PostgreSQL，并且初步感受一下它的魅力。</p>
<p>我们这里使用<strong>云主机</strong>来演示</p>
<p>首先拉取镜像，这里我们用相对稳定的postgresql:11.1</p>
<blockquote>
<p>docker pull postgresql:11.1</p>
</blockquote>
<p>拉取成功后，查看镜像</p>
<blockquote>
<p>docker images</p>
</blockquote>
<p><img src="/id_41/id_41%5C1.png" alt="镜像"></p>
<p>我们可以看到确实PostgreSQL比MySQL小</p>
<p>镜像拉取成功，我们现在可以启动容器了</p>
<blockquote>
<p>docker run -d –name dev-postgres -e POSTGRES_PASSWORD=root -p 5432:5432 postgres:11.1</p>
</blockquote>
<p>这里POSTGRES_PASSWORD是PostgrelSQL的用户密码，自己制定一个就可以了，默认端口号是5432.注意我们用的是云主机，要将云主机上的防火墙打开</p>
<p>查看容器运行状态</p>
<blockquote>
<p>docker ps</p>
</blockquote>
<p><img src="/id_41/id_41%5C2.png" alt="容器"></p>
<p>可以，现在我们的容器已经正常运行了</p>
<p>我们进入容器的命令行看一看</p>
<blockquote>
<p>docker exec -it dev-postgres bash </p>
<p>psql -h localhost -U postgres</p>
</blockquote>
<p>现在我们已经进入命令行了，在命令行输入PostgrelSQL的命令\l 就可以查看数据库列表。<br><img src="/id_41/id_41%5C3.png" alt="数据库"></p>
<p>建立数据库</p>
<blockquote>
<p>CREATE DATABASE mytest;</p>
</blockquote>
<p>使用数据库</p>
<blockquote>
<p>\c mytest</p>
</blockquote>
<p>建立一张表</p>
<blockquote>
<p>CREATE TABLE “public”.”article” (<br>    “id” int4 NOT NULL,<br>    “content” text,<br>    PRIMARY KEY (“id”)<br>)<br>WITH (OIDS=FALSE);</p>
</blockquote>
<p>列出所有表</p>
<blockquote>
<p>\d</p>
</blockquote>
<p>如果不习惯使用命令行，也可以用可视化工具来进行链接，比如Navicat<br><img src="/id_41/id_41%5C4.png" alt="可视化工具"><br>这里因为我们用的是云主机所以IP地址不能写本地，还有密码是我们上边指定的密码</p>
<p><strong>注意</strong> 默认用户是postgres，值得一提的是，使用navicat无法像Mysql一样手动设置属性自增长(auto-increment)，PostgreSQL使用的是序列的形式来实现自增长：</p>
<blockquote>
<p>CREATE SEQUENCE serial START 1;</p>
</blockquote>
<p>这里创建好的序列是从1开始计数。</p>
<p>随后，将需要设置的字段的默认值设为序列增长即可</p>
<blockquote>
<p>ALTER TABLE “public”.”article” ALTER COLUMN “id” SET DEFAULT nextval(‘serial’);</p>
</blockquote>
<p><strong>OVER子句</strong></p>
<p>我们现在有一个部门表empsal<br><img src="/id_41/id_41%5C5.png" alt="部门表"><br> 现在我想将每一个员工的工资与他所在部门的平均工资做个比较，怎么做？<br> 其实这也是leetcode原题，用mysql只能用子查询，而用PostgreSQL该查询可以很容易的实现</p>
<blockquote>
<p>mysql：</p>
<p>select t1.depname, t1.userid,t1.salary,t2.sal FROM empsalary t1 INNER JOIN (select depname,avg(salary) sal FROM empsalary group by depname) t2 ON t1.depname=t2.depname</p>
<p>OVER子句：</p>
<p>SELECT emp, name,salary,avg( salary ) OVER ( PARTITION BY emp )  FROM empsa;</p>
</blockquote>
<p>可以看到，这个查询中，聚合函数avg的含义没有变，仍然是求平均值。但和普通的聚合函数不同的是，它不再对表中所有的salary求平均值，而是针对同一个部门（PARTITION BY指定的depname）内的salary求平均值，而且得到的结果由同一个部门内的所有行共享，并没有将这些行合并，这就大大简化了sql的复杂度，同时也能很方便的解决 “每组取 top k” 的这类问题</p>
<p>在Django项目中使用PostgreSQL和使用mysql是一样的。在setting配置一下</p>
<p><strong>注意</strong>：我们是在云主机上整的postgreSQL,所以HOST不可以是本地的</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">DATABASES = {</span><br><span class="line">    <span class="string">'default'</span>: {</span><br><span class="line">        <span class="comment"># mysql配置</span></span><br><span class="line">        <span class="comment"># 'ENGINE': 'django.db.backends.mysql',</span></span><br><span class="line">        <span class="comment"># 'NAME': 'test',</span></span><br><span class="line">        <span class="comment"># 'PORT': 3306,</span></span><br><span class="line">        <span class="comment"># 'HOST': '127.0.0.1',</span></span><br><span class="line">        <span class="comment"># 'USER': 'root',</span></span><br><span class="line">        <span class="comment"># 'PASSWORD': '123456'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># postgreSQL配置</span></span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.postgresql_psycopg2'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'mytest'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">5432</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'39.***.***.***'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'postgres'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'root'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其他的就和MySQL一样啦</p>
<p>原文转载自「刘悦的技术博客」<span class="exturl"><a class="exturl__link" href="https://v3u.cn/a_id_171">https://v3u.cn/a_id_171</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>Httpx测试脚本</title>
    <url>/id_6/</url>
    <content><![CDATA[<p>在 Python 众多的 HTTP 客户端中，最有名的莫过于<strong>requests</strong>、<strong>aiohttp</strong>和<strong>httpx</strong>。<br>在不借助其他第三方库的情况下，<strong>requests</strong>只能发送同步请求；<strong>aiohttp</strong>只能发送异步请求；<br><strong>httpx</strong>既能发送同步请求，又能发送异步请求</p>
<a id="more"></a>
<blockquote>
<p>所谓的<strong>同步</strong>请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。<br>所谓<strong>异步</strong>请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求</p>
</blockquote>
<p>那么我们篇文章就来介绍一下使用<strong>httpx</strong>编写测试脚本发送请求</p>
<ul>
<li>相关问题：</li>
</ul>
<p><strong>问</strong>：怎么在终端运行python文件？<br><strong>答</strong>：在终端运行python文件，需要先进到要运行的文件目录下，然后 python 文件名<br>废话不多说，上代码。</p>

        <h3 id="用httpx发送同步请求-和requests就差个关键字">
          <a href="#用httpx发送同步请求-和requests就差个关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#用httpx发送同步请求-和requests就差个关键字" class="headerlink" title="用httpx发送同步请求(和requests就差个关键字)"></a>用httpx发送同步请求(和requests就差个关键字)</h3>
      <p>httpx由于支持异步请求，所以发送大量的请求时，httpx的效率是优于requests的</p>
<figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># httpx发送请求</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://127.0.0.1:8000/p8/user/'</span></span><br><span class="line">data = {</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'admin'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = httpx.post(url=url,data=data)</span><br><span class="line"><span class="comment"># requests发送请求</span></span><br><span class="line"><span class="comment"># r = requests.post(url=url,data=data)</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="用httpx发送异步请求">
          <a href="#用httpx发送异步请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#用httpx发送异步请求" class="headerlink" title="用httpx发送异步请求"></a>用httpx发送异步请求</h3>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">url = <span class="string">'http://127.0.0.1:8000/p8/user/'</span></span><br><span class="line">data = {</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'before'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">}</span><br><span class="line">update = {</span><br><span class="line">    <span class="string">'uid'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'abc'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        r = <span class="keyword">await</span> client.get(url)</span><br><span class="line">        c = <span class="keyword">await</span> client.post(url, data=data)</span><br><span class="line">        u = <span class="keyword">await</span> client.put(url, data=update)</span><br><span class="line">        d = <span class="keyword">await</span> client.delete(url, params={<span class="string">'uid'</span>: <span class="number">1</span>})</span><br><span class="line">        print(<span class="string">"查"</span>, r.json())</span><br><span class="line">        print(<span class="string">"填"</span>, c.json())</span><br><span class="line">        print(<span class="string">"改"</span>, u.json())</span><br><span class="line">        print(<span class="string">"删"</span>, d.json())</span><br><span class="line"></span><br><span class="line">asyncio.run(fun())</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="快拿去测试接口吧">
          <a href="#快拿去测试接口吧" class="heading-link"><i class="fas fa-link"></i></a><a href="#快拿去测试接口吧" class="headerlink" title="快拿去测试接口吧"></a>快拿去测试接口吧</h3>
      ]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>httpx</tag>
      </tags>
  </entry>
  <entry>
    <title>排行榜实现</title>
    <url>/id_42/</url>
    <content><![CDATA[<p>目前我们要设计一个功能</p>
<p>也就是用户的排行榜,首先我们要知道排行榜都有哪些特点，好选择合适的数据类型去做。我们还要知道排行榜的底层是什么?</p>
<a id="more"></a>       


        <h4 id="需求分析">
          <a href="#需求分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4>
      <p>排行榜有哪些特点</p>
<pre><code>1. **有序**
 2. **唯一**
 3. **实时更新**</code></pre>
<p>那我们现在知道排行榜的特点了，应该选择数据结构，从整体来看，使用Redis中的有序集合是最合适的</p>
<p>所以我们可以通过利用<strong>redis</strong>的<strong>sorted set</strong>来进行设计，</p>
<p>那为什么要用redis来实现，而不是使用传统数据库？</p>
<p><strong>问</strong>：为什么不使用传统数据库？</p>
<p>一、 用户排行榜属于热点数据，点击量高，所以使用redis要比使用mysql等传统数据库速度方面有优势</p>
<p>二、 传统数据库的limit限制了查询排名靠后玩家的性能 举个例子： 当我们每页显示100名玩家，去查询第101页的时候，那么我们的sql中limit语句为</p>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">limit <span class="number">10000</span> <span class="number">100</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>这个语句在执行的过程中会先扫描 100100个数据节点（假设有索引的情况下，没有索引则是全表扫描）<br>然后取出最后100条数据，这么执行实际上很没有效率，查询很靠后的用户排名的时候很容易出现慢查询。</p>
<p>Redis的有序集合又能很好的避免这个问题</p>
<p>既然要使用有序集合，我们先来了解一下有序集合的底层：</p>
<p>有序集合的底层我们可以看做是一个链表，通过指针来指向下一个内存地址</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker打包镜像</title>
    <url>/id_5/</url>
    <content><![CDATA[<p>在docker hub上有时我们找不到想要的image,或自己想要打包纯净的image ( 怕投毒?? ).</p>
<p>所以自己制作docker image是一种不错的选择</p>
<a id="more"></a>

        <h5 id="拉取镜像">
          <a href="#拉取镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5>
      <blockquote>
<p>docker pull centos</p>
</blockquote>

        <h5 id="查看镜像">
          <a href="#查看镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5>
      <blockquote>
<p>docker images</p>
</blockquote>

        <h5 id="创建容器">
          <a href="#创建容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h5>
      <blockquote>
<p>docker run -it –name=容器名  镜像名  /bin/bash</p>
</blockquote>

        <h5 id="启动容器">
          <a href="#启动容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h5>
      <blockquote>
<p>docker start 容器ID</p>
</blockquote>

        <h5 id="进入容器">
          <a href="#进入容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5>
      <blockquote>
<p>docker exec -itd 容器名(容器ID) /bin/bash<br>docker attach 容器ID</p>
</blockquote>

        <h5 id="安装ssh">
          <a href="#安装ssh" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h5>
      <blockquote>
<p>yum install openssh-server</p>
</blockquote>
<p>没有正常启动的话通常需要生成当前主机的ssh-key</p>
<blockquote>
<p>ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key<br>ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key<br>ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key<br>ssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key</p>
</blockquote>

        <h5 id="在容器中启动ssh服务，让外界可以连接">
          <a href="#在容器中启动ssh服务，让外界可以连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#在容器中启动ssh服务，让外界可以连接" class="headerlink" title="在容器中启动ssh服务，让外界可以连接"></a>在容器中启动ssh服务，让外界可以连接</h5>
      <blockquote>
<p>/usr/sbin/sshd</p>
</blockquote>

        <h5 id="修改容器内部密码">
          <a href="#修改容器内部密码" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改容器内部密码" class="headerlink" title="修改容器内部密码"></a>修改容器内部密码</h5>
      <blockquote>
<p>修改密码需要安装passwd<br>yum install passwd.x86_64<br>修改密码<br>passwd root</p>
</blockquote>

        <h5 id="退出容器">
          <a href="#退出容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5>
      <blockquote>
<p>exit</p>
</blockquote>

        <h5 id="修改云主机密码">
          <a href="#修改云主机密码" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改云主机密码" class="headerlink" title="修改云主机密码"></a>修改云主机密码</h5>
      <blockquote>
<p>修改云主机密码需要退出容器在执行passwd</p>
</blockquote>

        <h5 id="查看所有容器">
          <a href="#查看所有容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h5>
      <blockquote>
<p>docker ps -a</p>
</blockquote>

        <h5 id="制作镜像">
          <a href="#制作镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h5>
      <blockquote>
<p>docker commit -a “作者” -m “简介”  被打包的容器ID  镜像名: 版本号</p>
</blockquote>

        <h5 id="镜像导出">
          <a href="#镜像导出" class="heading-link"><i class="fas fa-link"></i></a><a href="#镜像导出" class="headerlink" title="镜像导出"></a>镜像导出</h5>
      <blockquote>
<p>docker save 镜像名 &gt; ./文件名<br>例如： docker save ssh_image &gt; ./文件名</p>
</blockquote>

        <h5 id="加载镜像-解压">
          <a href="#加载镜像-解压" class="heading-link"><i class="fas fa-link"></i></a><a href="#加载镜像-解压" class="headerlink" title="加载镜像(解压)"></a>加载镜像(解压)</h5>
      <blockquote>
<p>docker load &lt; ./文件名<br>例如： docker load &lt; ./文件名</p>
</blockquote>

        <h5 id="查看镜像是否存在">
          <a href="#查看镜像是否存在" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看镜像是否存在" class="headerlink" title="查看镜像是否存在"></a>查看镜像是否存在</h5>
      <blockquote>
<p>docker images</p>
</blockquote>

        <h5 id="创建容器并映射端口把镜像跑起来">
          <a href="#创建容器并映射端口把镜像跑起来" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建容器并映射端口把镜像跑起来" class="headerlink" title="创建容器并映射端口把镜像跑起来"></a>创建容器并映射端口把镜像跑起来</h5>
      <blockquote>
<p>docker run -itd -p 11111:22(映射的端口号)  镜像ID  /bin/bash</p>
</blockquote>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 and NLP</title>
    <url>/id_43/</url>
    <content><![CDATA[<a id="more"></a>       ]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>VUE路由钩子</title>
    <url>/id_9/</url>
    <content><![CDATA[<p>描述：通常我们在跳转页面时会遇到各种各样的要求，比如没有登录不能查看，比如跳转需要验证，各种各样的要求。如果分开写代码的话就会显得很乱，代码很繁重，此时就用到了我们的路由钩子<br>路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的</p>
<a id="more"></a>

        <h4 id="路由钩子主要分三种">
          <a href="#路由钩子主要分三种" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由钩子主要分三种" class="headerlink" title="路由钩子主要分三种"></a><strong>路由钩子</strong>主要分三种</h4>
      <p>全局路由钩子：beforeEach<br>单个路由钩子：beforeEnter<br>路由组件钩子：beforeEachEnter</p>

        <h4 id="三种路由钩子中都涉及到了三个参数">
          <a href="#三种路由钩子中都涉及到了三个参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#三种路由钩子中都涉及到了三个参数" class="headerlink" title="三种路由钩子中都涉及到了三个参数:"></a>三种路由钩子中都涉及到了三个参数:</h4>
      <p>to: Route: 即将要进入的目标 路由对象<br>from: Route: 当前导航正要离开的路由<br>next: Function: 通过这个方法来调用下一个钩子函数</p>

        <h4 id="使用：">
          <a href="#使用：" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4>
      <p>beforeEach(跳转前)  &amp;&amp;  afterEach(跳转后)<br>需要通过main.js配置</p>
<hr>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">//会在任意路由跳转前执行，next一定要记着执行，不然路由不能跳转了</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我要跳转啦"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(to,<span class="keyword">from</span>)</span><br><span class="line">  <span class="comment">//调用下一个钩子函数</span></span><br><span class="line">  next()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">//会在任意路由跳转后执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我跳过来了'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></div></figure>
<p>beforeEnter(写在router-index.js里面)</p>
<hr>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/index'</span>,</span><br><span class="line">      name: <span class="string">'Index'</span>,</span><br><span class="line">      component: Index,</span><br><span class="line">      <span class="function"><span class="title">beforeEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是只守护Index的beforeEnter"</span>)</span><br><span class="line">        next()</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></div></figure>
<p>beforeRouteEnter(到达之后)   &amp;&amp;   beforeRouteUpdate(到达子路由)   &amp;&amp;   beforeRouteLeave(离开之前)<br>写在具体页面里</p>
<hr>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"****************Test1****我来啦**************"</span>);</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> {</span><br><span class="line">    <span class="comment">//因为当钩子执行前，组件实例还没被创建</span></span><br><span class="line">    <span class="comment">// vm 就是当前组件的实例相当于上面的 this，所以在 next 方法里你就可以把 vm 当 this 来用了。</span></span><br><span class="line">    <span class="built_in">console</span>.log(vm);<span class="comment">//当前组件的实例</span></span><br><span class="line">  });</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> {</span><br><span class="line">  <span class="comment">//在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">  <span class="comment">//对于一个带有动态参数的路径 /good/:id，在 /good/1 和 /good/2 之间跳转的时候，</span></span><br><span class="line">  <span class="comment">// 由于会渲染同样的good组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">  <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//简单来说就是在跳转子路由的时候可以获取query和params</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"****************Test1*******Update***********"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">'Update'</span>); <span class="comment">//当前组件实例</span></span><br><span class="line">  next();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> {</span><br><span class="line">  <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">  <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"****************Test1****我走啦**************"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">'Leave'</span>); <span class="comment">//当前组件实例</span></span><br><span class="line">  next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE父子组件</title>
    <url>/id_7/</url>
    <content><![CDATA[<h4 id="VUE父子组件使用">
          <a href="#VUE父子组件使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#VUE父子组件使用" class="headerlink" title="VUE父子组件使用"></a>VUE父子组件使用</h4>
      <p>在vue组件通信中其中最常见通信方式就是父子组件之中的通信，而父子组件的设定方式在不同情况下又各有不同。<br>最常见的就是父组件为控制组件，子组件为视图组件。<br>父组件传递数据给子组件使用，遇到业务逻辑操作时子组件触发父组件的自定义事件。<br>但是，无论哪种组织方式父子组件的通信方式都是大同小异</p>
<a id="more"></a>


        <h4 id="父组件向子组件传参">
          <a href="#父组件向子组件传参" class="heading-link"><i class="fas fa-link"></i></a><a href="#父组件向子组件传参" class="headerlink" title="父组件向子组件传参"></a>父组件向子组件传参</h4>
      <p><strong>通过 [props]传递数据 (推荐)</strong></p>
<p>父子通讯中最常见的数据传递方式就是通过props传递数据，就好像方法的传参一样，父组件调用子组件并传入数据，子组件接受到父组件传递的数据进行验证<br>使用props 可以是数组或对象，用于接收来自父组件的数据。<br>props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值prop 的定义应该尽量详细，至少需要指定其类型</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 父组件  Father --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Son :parentMessage="parentMessage"&gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from "./Son";</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  components: {</span><br><span class="line">    Son</span><br><span class="line">  },</span><br><span class="line">  data() {</span><br><span class="line">    return {</span><br><span class="line">      parentMessage: "我是来自父组件的消息，借用一下子组件的地方渲染一下"</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></tbody></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 子组件 Son  --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;你好哇&lt;/h1&gt;</span><br><span class="line">    &lt;span&gt;{{ parentMessage }}&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  mounted() {</span><br><span class="line">    console.log(this.parentMessage)</span><br><span class="line">  },</span><br><span class="line">  //第一种方法  </span><br><span class="line">  // props: ['parentMessage']</span><br><span class="line">  //第二种方法</span><br><span class="line">    props: {</span><br><span class="line">      parentMessage: {</span><br><span class="line">        type: String,</span><br><span class="line">        default: '子组件默认显示的信息',</span><br><span class="line">        require: true</span><br><span class="line">      }</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>
<p>效果：<br><img src="/id_7/01.png" alt="父子组件传参"></p>

        <h4 id="子组件向父组件传参">
          <a href="#子组件向父组件传参" class="heading-link"><i class="fas fa-link"></i></a><a href="#子组件向父组件传参" class="headerlink" title="子组件向父组件传参"></a>子组件向父组件传参</h4>
      <p><strong>通过 [$emit]传递数据 (推荐)</strong><br>通过 $emit 传递父组件数据与父组件到子组件通讯中的$on配套使用，可以向父组件中触发的方法传递参数供父组件使用。</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 父组件  Father --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;h1&gt;{{data}}&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Son @event="change"&gt;&lt;/Son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from "./Son";</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  components: {</span><br><span class="line">    Son</span><br><span class="line">  },</span><br><span class="line">  data() {</span><br><span class="line">    return {</span><br><span class="line">      data:"我是父组件"</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">    methods: {</span><br><span class="line">      change(event) {</span><br><span class="line">        this.data = event</span><br><span class="line">          console.log(event)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></tbody></table></div></figure>

<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 子组件 Son  --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button @click="toFather"&gt;向父组件传值&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  data(){</span><br><span class="line">    return{</span><br><span class="line">      data:"我是子组件"</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  methods:{</span><br><span class="line">      toFather(){</span><br><span class="line">        this.$emit('event', this.data)</span><br><span class="line">      }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></tbody></table></div></figure>
<p>效果：<br><img src="/id_7/02.png" alt="子父组件传参"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE拦截器</title>
    <url>/id_8/</url>
    <content><![CDATA[<p>vue拦截器axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端,<br>他主要分为请求拦截器和响应拦截器…</p>
<a id="more"></a>

<p><strong>请求拦截器</strong>：就是我们在请求之前进行的一个操作比如说，我们可以在请求之前加一个loading框，在响应拦截后进行loading框的一个去除。</p>
<p><strong>响应拦截器</strong>：就是请求得到回应，我们可以做一个状态的拦截，比如说405，404等等状态吗，我们可以做一个拦截，然后在页面进行响应的展示</p>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>{</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么,比如把token携带过去</span></span><br><span class="line">  <span class="keyword">let</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">'token'</span>);</span><br><span class="line">  <span class="comment">// 如果有token, 就可以进行操作</span></span><br><span class="line">  <span class="keyword">if</span> (token) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始请求啦"</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">}, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>{</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>
<p>请求拦截器通常在用户身份认证的时候使用，便于携带用户的身份认证信息token之类的</p>
<figure class="highlight js"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器（当后端返回数据的时候进行拦截）</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">  <span class="comment">// 当响应码是 2xx 的情况, 进入这里</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"请求成功，开始响应啦"</span>)</span><br><span class="line">  <span class="keyword">return</span> response.data;</span><br><span class="line">}, <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(error.response)</span><br><span class="line">  <span class="comment">// 当响应码不是 2xx 的情况, 进入这里</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"请求失败了哦"</span>)</span><br><span class="line">  <span class="keyword">return</span> error</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>作用</strong>：</p>
<ul>
<li>比如config中的一些信息不符合服务器的要求，得及时拦截下来更改。</li>
<li>比如每次发送网络请求的时候，都希望在界面中显示一个动态加载的请求图标，就是一直在转圈圈，让用户知道当前页面正在加载数据，准备渲染视图。</li>
<li>比如某些网络请求（比如登录token）,必须携带一些特殊的信息。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ECharts 的使用</title>
    <url>/id_44/</url>
    <content><![CDATA[<h3 id="echarts-实例">
          <a href="#echarts-实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#echarts-实例" class="headerlink" title="echarts 实例"></a>echarts 实例</h3>
      <p>一个网页中可以创建多个 echarts 实例 。每个 echarts 实例 中可以创建多个图表和坐标系等等（用 option 来描述）。准备一个 DOM 节点（作为 echarts 的渲染容器），就可以在上面创建一个 echarts 实例。每个 echarts 实例独占一个 DOM 节点。</p>
<p><img src="https://i.loli.net/2021/04/20/cLw2RT3pnZU5zot.png" alt="实例1.png"></p>

        <h3 id="系列（series）">
          <a href="#系列（series）" class="heading-link"><i class="fas fa-link"></i></a><a href="#系列（series）" class="headerlink" title="系列（series）"></a>系列（series）</h3>
      <ul>
<li><p>系列 （series）是很常见的名词。在 echarts 里， 系列 （series）是指：一组数值以及他们映射成的图。“系列” 这个词原本可能来源于 “一系列的数据”，而在 echarts 中取其扩展的概念，不仅表示数据，也表示数据映射成为的图。所以，一个 系列 包含的要素至少有：一组数值、图表类型（ series.type ）、以及其他的关于这些数据如何映射成图的参数。</p>
</li>
<li><p> echarts 里系列类型（ series.type ）就是图表类型。系列类型（ series.type ）至少有：line（折线图）、bar（柱状图）、pie（饼图）、scatter（散点图）、graph（关系图）、tree（树图）</p>
</li>
<li><p> 如下图，右侧的 option 中声明了三个 系列 （series）：pie（饼图系列）、line（折线图系列）、bar（柱状图系列），每个系列中有他所需要的数据（series.data）</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/04/20/lDtcuE531YvyWS7.png" alt="系列1.png"></p>
<ul>
<li>类同地，下图中是另一种配置方式，系列的数据从 dataset 中取：</li>
</ul>
<p><img src="https://i.loli.net/2021/04/20/xWT3XwbJOioeAS9.png" alt="实例2.png"></p>

        <h3 id="组件（component）">
          <a href="#组件（component）" class="heading-link"><i class="fas fa-link"></i></a><a href="#组件（component）" class="headerlink" title="组件（component）"></a>组件（component）</h3>
      <ul>
<li>在系列之上，echarts 中各种内容，被抽象为 “组件”。例如，echarts 中至少有这些组件：xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）、angleAxis（极坐标系角度轴）、radiusAxis（极坐标系半径轴）、polar（极坐标系底板）、geo（地理坐标系）、dataZoom（数据区缩放组件）、visualMap（视觉映射组件）、tooltip（提示框组件）、toolbox（工具栏组件）、series（系列）、… </li>
<li>我们注意到，其实系列（series）也是一种组件，可以理解为：系列是专门绘制 “图” 的组件。 </li>
<li>如下图，右侧的 option 中声明了各个组件（包括系列），各个组件就出现在图中。</li>
</ul>
<p><img src="https://i.loli.net/2021/04/20/6wEDF9luaCN4KPW.png" alt="组件.png"></p>

        <h2 id="话不多说上代码">
          <a href="#话不多说上代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#话不多说上代码" class="headerlink" title="话不多说上代码"></a>话不多说上代码</h2>
      
        <h3 id="直接引入-echarts">
          <a href="#直接引入-echarts" class="heading-link"><i class="fas fa-link"></i></a><a href="#直接引入-echarts" class="headerlink" title="直接引入 echarts"></a>直接引入 echarts</h3>
      <ul>
<li><p><strong>安装 echarts 项目依赖</strong></p>
<figure class="highlight shell"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br><span class="line">// 或者</span><br><span class="line">npm install echarts -S</span><br></pre></td></tr></tbody></table></div></figure></li>
<li><p><strong>全局引入</strong></p>
<p>我们安装完成之后，可以在 main.js 中全局引入 echarts</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">import echarts from "echarts";</span><br><span class="line">Vue.prototype.$echarts = echarts;</span><br></pre></td></tr></tbody></table></div></figure></li>
<li><p><strong>创建柱形图表</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">    &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: "app",</span><br><span class="line">  methods: {</span><br><span class="line">    drawChart() {</span><br><span class="line">      // 基于准备好的dom，初始化echarts实例</span><br><span class="line">      let myChart = this.$echarts.init(document.getElementById("main"));</span><br><span class="line">      // 指定图表的配置项和数据</span><br><span class="line">      let option = {</span><br><span class="line">        title: {</span><br><span class="line">          text: "ECharts 入门示例"</span><br><span class="line">        },</span><br><span class="line">        tooltip: {},</span><br><span class="line">        legend: {</span><br><span class="line">          data: ["销量"]</span><br><span class="line">        },</span><br><span class="line">        xAxis: {</span><br><span class="line">          data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]</span><br><span class="line">        },</span><br><span class="line">        yAxis: {},</span><br><span class="line">        series: [</span><br><span class="line">          {</span><br><span class="line">            name: "销量",</span><br><span class="line">            type: "bar",</span><br><span class="line">            data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">          }</span><br><span class="line">        ]</span><br><span class="line">      };</span><br><span class="line">      // 使用刚指定的配置项和数据显示图表。</span><br><span class="line">      myChart.setOption(option);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  mounted() {</span><br><span class="line">    this.drawChart();</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></div></figure></li>
<li><p>用 websocket 实现实时折线图</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="myChart" class="chart" :style="{width: '100%', height: '500px'}" :option='loadLine'&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import echarts from 'echarts'</span><br><span class="line">export default {</span><br><span class="line">  name: 'xwPassengerFlow',</span><br><span class="line">  data() {</span><br><span class="line">    return {</span><br><span class="line">      Time: [], //x 轴数据，可根据需求</span><br><span class="line">      NewZealand: [], // 数据 1</span><br><span class="line">      USA: [], // 数据 2</span><br><span class="line">      Australia:[] // 数据 3</span><br><span class="line">      </span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  mounted() {</span><br><span class="line">       this.loadLine()       // 渲染折线图</span><br><span class="line">       this.websocketinit()  // 钩子函数中链接 websocket</span><br><span class="line">  },</span><br><span class="line">  watch:{    // 实现监听，当有新数据再次渲染</span><br><span class="line">  		Time:function(){</span><br><span class="line">  			this.loadLine()</span><br><span class="line">  		}</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    loadLine() {</span><br><span class="line">      var option = {</span><br><span class="line">        title: {</span><br><span class="line">          text: '折线图堆叠'</span><br><span class="line">        },</span><br><span class="line">        tooltip: {</span><br><span class="line">          trigger: 'axis'</span><br><span class="line">        },</span><br><span class="line">        legend: {</span><br><span class="line">          data:[ '新西兰元', '澳大利亚元', '美元']</span><br><span class="line">        },</span><br><span class="line">        grid: {</span><br><span class="line">          left: '3%',</span><br><span class="line">          right: '4%',</span><br><span class="line">          bottom: '3%',</span><br><span class="line">          containLabel: true</span><br><span class="line">        },</span><br><span class="line">        xAxis: {</span><br><span class="line">          type: 'category',</span><br><span class="line">          boundaryGap: false,</span><br><span class="line">          data: this.Time //x 轴数据</span><br><span class="line">        },</span><br><span class="line">        yAxis: {</span><br><span class="line">          type: 'value'</span><br><span class="line">        },</span><br><span class="line">        series: [</span><br><span class="line">        </span><br><span class="line">          {</span><br><span class="line">            name: '新西兰元',</span><br><span class="line">            type: 'line',</span><br><span class="line">      </span><br><span class="line">            data: this.NewZealand //y 轴数据 2</span><br><span class="line">          },</span><br><span class="line">          {</span><br><span class="line">            name: '澳大利亚元',</span><br><span class="line">            type: 'line',</span><br><span class="line">            data: this.Australia//y 轴数据 3</span><br><span class="line">          },</span><br><span class="line">          {</span><br><span class="line">            name: '美元',</span><br><span class="line">            type: 'line',</span><br><span class="line">            stack: '总量',</span><br><span class="line">            data: this.USA //y 轴数据 5</span><br><span class="line">          },</span><br><span class="line">       </span><br><span class="line">        ]</span><br><span class="line">      }</span><br><span class="line">      this.myChartOne = echarts.init(document.getElementById('myChart'))</span><br><span class="line">      this.myChartOne.setOption(option)</span><br><span class="line">    },</span><br><span class="line">     // 连接聊天</span><br><span class="line">    websocketinit:function(){</span><br><span class="line">        // 判断浏览器是否支持 websocket</span><br><span class="line">  if('WebSocket' in window){</span><br><span class="line">    console.log('支持')</span><br><span class="line">    // 生成 websocket 连接</span><br><span class="line">    var ws = new WebSocket('ws://192.168.1.27:8000/apps/websocketlink/')</span><br><span class="line">    // var ws = new WebSocket('ws://192.168.1.157:8000/chat_room_websocket/')</span><br><span class="line">    // 发送链接请求</span><br><span class="line">    ws.onopen = function () {</span><br><span class="line">      ws.send('test')</span><br><span class="line">    }</span><br><span class="line">    // 发送消息</span><br><span class="line">    ws.onmessage =  (evt) =&gt;{</span><br><span class="line">      // 将获取信息打印</span><br><span class="line">      console.log(evt.data)</span><br><span class="line">      var msg =JSON.parse(evt.data) </span><br><span class="line">      this.Time.push(msg.Time)</span><br><span class="line">      this.NewZealand.push(msg.NewZealand)</span><br><span class="line">      this.Australia.push(msg.Australia)</span><br><span class="line">      this.USA.push(msg.USA) </span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    ws.onerror = (e)=&gt;{</span><br><span class="line">      console.log('错误信息',e)</span><br><span class="line">      // this.websocketinit()</span><br><span class="line">    }</span><br><span class="line">    // 捕获断开连接</span><br><span class="line">    ws.onclose = function () {</span><br><span class="line">      console.log('链接已关闭')</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  }</span><br><span class="line">}}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></div></figure>
</li>
</ul>
]]></content>
  </entry>
</search>
