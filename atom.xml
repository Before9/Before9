<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I hope you&#39;re here for me</title>
  
  <subtitle>贩卖日落</subtitle>
  <link href="https://www.hr915.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.hr915.xyz/"/>
  <updated>2021-04-08T00:21:35.689Z</updated>
  <id>https://www.hr915.xyz/</id>
  
  <author>
    <name>Before</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集合(SET)</title>
    <link href="https://www.hr915.xyz/id_39/"/>
    <id>https://www.hr915.xyz/id_39/</id>
    <published>2018-10-05T13:32:17.000Z</published>
    <updated>2021-04-08T00:21:35.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）是一个无序的不重复元素序列。一般用于去重。<br>当元素的顺序性没有唯一性重要的时候，使用到SET去重</p><a id="more"></a><p>集合又分为可变集合和不可变集合</p><p>可变集合(set)：通过add等方法可以动态修改set中的内容</p><p>不可变集合(frozenset)：顾名思义，他的元素是不可变的</p><blockquote><p>frozenset()是一个函数，会返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ol><li>不同元素组成（元素不能重复）</li><li>无序（集合元素的顺序和定义、添加的顺序不一致）</li><li>集合中的元素必须是不可变类型</li></ol><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集合SET去重操作原理: 必须要有另外一个容器作比对，</span></span><br><span class="line"><span class="comment"># 比如每样鱼我要来一条，那么我旁边就需要有一个新的鱼缸，然后把挑选出来的鱼放进新鱼缸中，捞第二条的时候用眼睛和第一条作比对</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">mylist = []</span><br><span class="line"></span><br><span class="line">[mylist.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> mylist]</span><br><span class="line"></span><br><span class="line">print(mylist)</span><br></pre></td></tr></tbody></table></figure><p>延伸一下append的底层原理：</p><blockquote><p>append其实是用到了队列,先进先出的概念</p><p>跟append一起的还有insert，两个的差别在于一个从头部插入，一个从尾部插入</p></blockquote><h4 id="集合的创建："><a href="#集合的创建：" class="headerlink" title="集合的创建："></a>集合的创建：</h4><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集合</span></span><br><span class="line">parame = {<span class="number">1</span>,<span class="number">2</span>}</span><br><span class="line">print(<span class="built_in">type</span>(parame))</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">a = <span class="string">'hello'</span></span><br><span class="line">print(<span class="built_in">set</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建空集合</span></span><br><span class="line">myset = <span class="built_in">set</span>()</span><br><span class="line">print(<span class="built_in">type</span>(myset))</span><br></pre></td></tr></tbody></table></figure><h4 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h4><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td><td align="left">为集合添加元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td><td align="left">拷贝一个集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td><td align="left">返回多个集合的差集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td><td align="left">返回集合的交集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td><td align="left">返回集合的交集。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td><td align="left">随机移除元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td><td align="left">移除指定元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td><td align="left">返回两个集合的并集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td><td align="left">给集合添加元素</td></tr></tbody></table><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向一个空集合中添加元素</span></span><br><span class="line">myset = <span class="built_in">set</span>()</span><br><span class="line">myset.add(<span class="string">'hello'</span>)</span><br><span class="line">print(myset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># update可以添加多个参数，可以是列表，元组，字典等，参数用逗号隔开</span></span><br><span class="line">myset = <span class="built_in">set</span>()</span><br><span class="line">myset.update(<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>],{<span class="number">3</span>:<span class="number">4</span>},(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">print(myset)</span><br></pre></td></tr></tbody></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机删除一个元素  pop</span></span><br><span class="line">parame = {<span class="number">1</span>,<span class="number">2</span>}</span><br><span class="line">parame.pop()</span><br><span class="line">print(parame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定元素 remove,元素不存在报错</span></span><br><span class="line">myset = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">myset.remove(<span class="number">4</span>)</span><br><span class="line">print(myset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定元素 discard,元素不存在不会报错</span></span><br><span class="line">myset = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">myset.discard(<span class="number">7</span>)</span><br><span class="line">print(myset)</span><br></pre></td></tr></tbody></table></figure><h4 id="集合的运算符"><a href="#集合的运算符" class="headerlink" title="集合的运算符"></a>集合的运算符</h4><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>-</strong></td><td align="left">集合a中包含而集合b中不包含的元素</td></tr><tr><td align="left">|</td><td align="left">集合a或b中包含的所有元素</td></tr><tr><td align="left">&amp;</td><td align="left">集合a和b中都包含了的元素</td></tr><tr><td align="left">^</td><td align="left">不同时包含于a和b的元素</td></tr></tbody></table><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">'123456'</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">'456789'</span>)</span><br></pre></td></tr></tbody></table></figure><h5 id="集合a中包含而集合b中不包含的元素"><a href="#集合a中包含而集合b中不包含的元素" class="headerlink" title="集合a中包含而集合b中不包含的元素"></a>集合a中包含而集合b中不包含的元素</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a - b)</span><br><span class="line"><span class="comment"># {'1', '2', '3'}</span></span><br></pre></td></tr></tbody></table></figure><h5 id="集合a或b中包含的所有元素"><a href="#集合a或b中包含的所有元素" class="headerlink" title="集合a或b中包含的所有元素"></a>集合a或b中包含的所有元素</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a | b)</span><br><span class="line"><span class="comment"># {'1', '4', '5', '2', '8', '3', '6', '7', '9'}</span></span><br></pre></td></tr></tbody></table></figure><h5 id="集合a和b中都包含了的元素"><a href="#集合a和b中都包含了的元素" class="headerlink" title="集合a和b中都包含了的元素"></a>集合a和b中都包含了的元素</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a &amp; b)</span><br><span class="line"><span class="comment"># {'4', '5', '6'}</span></span><br></pre></td></tr></tbody></table></figure><h5 id="不同时包含于a和b的元素"><a href="#不同时包含于a和b的元素" class="headerlink" title="不同时包含于a和b的元素"></a>不同时包含于a和b的元素</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a ^ b)</span><br><span class="line"><span class="comment"># {'8', '3', '7', '9', '1', '2'}</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h3&gt;&lt;p&gt;集合（set）是一个无序的不重复元素序列。一般用于去重。&lt;br&gt;当元素的顺序性没有唯一性重要的时候，使用到SET去重&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.hr915.xyz/categories/python/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
    <category term="类型" scheme="https://www.hr915.xyz/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Sort和Sorted区别</title>
    <link href="https://www.hr915.xyz/id_38/"/>
    <id>https://www.hr915.xyz/id_38/</id>
    <published>2018-10-04T13:32:17.000Z</published>
    <updated>2021-04-07T06:21:11.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>我们需要对List进行排序，Python提供了两个方法<br>对给定的List L进行排序，<br>方法1.用List的成员函数sort进行排序<br>方法2.用内建函数sorted进行排序（从python 2.4开始）</p><a id="more"></a><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>sort函数定义：sort(cmp=None, key=None, reverse=False)<br>sorted函数定义：sorted(iterable, cmp=None, key=None, reverse=False)</p><p>参数解析：<br>iterable：是可迭代类型;<br>cmp：用于比较的函数（大于时返回1，小于时返回-1，等于时返回0），比较什么由key决定,有默认值，迭代集合中的一项;<br>key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;<br>reverse：排序规则. reverse = True 或者 reverse = False，有默认值。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h4><ol><li>sort( )函数时对已存在的列表进行操作，调用其没有返回值；<br>而sorted( )函数是返回一个新的list,不在原来的list上进行操作，调用其返回一个排好序的list。</li><li>sorted()不会改变原来的list，而是会返回一个新的已经排序好的list<br>list.sort()方法仅仅被list所定义，sorted()可用于任何一个可迭代对象</li></ol><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>示例1:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line"> </span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">d = <span class="built_in">sorted</span>(c)</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line">print(c)</span><br></pre></td></tr></tbody></table></figure><p>得：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure><p>示例1是采用函数默认的设置</p><ul><li>对于排序参数设置，主要有以下两种：基于key；基于reverse。<br>示例2: 基于key和reverse</li></ul><p>1.reverse实现降序排序，需要提供一个布尔值，默认为False（升序排列）。<br>2.key在使用时必须提供一个排序过程总调用的函数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alist  =  [( <span class="string">'2'</span> ,  <span class="string">'3'</span> ,  <span class="string">'10'</span> ), ( <span class="string">'1'</span> ,  <span class="string">'2'</span> ,  <span class="string">'3'</span> ), ( <span class="string">'5'</span> ,  <span class="string">'6'</span> ,  <span class="string">'7'</span> ), ( <span class="string">'2'</span> ,  <span class="string">'5'</span> ,  <span class="string">'10'</span> ), ( <span class="string">'2'</span> ,  <span class="string">'4'</span> ,  <span class="string">'10'</span> )]</span><br><span class="line"><span class="comment"># 多级排序，先按照第3个元素排序，然后按照第2个元素排序：</span></span><br><span class="line"><span class="comment"># reverse = False 降序</span></span><br><span class="line">print(<span class="built_in">sorted</span>(alist, key=<span class="keyword">lambda</span>  x:( <span class="built_in">int</span> (x[ <span class="number">2</span> ]),<span class="built_in">int</span> (x[ <span class="number">1</span> ])),reverse  =  <span class="literal">False</span> )) </span><br><span class="line"><span class="comment"># reverse = False 升序</span></span><br><span class="line">alist.sort(key=<span class="keyword">lambda</span>  x:( <span class="built_in">int</span> (x[ <span class="number">2</span> ]),<span class="built_in">int</span> (x[ <span class="number">1</span> ])),reverse  =  <span class="literal">True</span> )</span><br><span class="line">print(alist)</span><br></pre></td></tr></tbody></table></figure><p>得：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>), (<span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>), (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'10'</span>)]</span><br><span class="line">[(<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'10'</span>), (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'10'</span>), (<span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>)]```</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>1、函数sorted()不改变原来的list，而是返回一个新的排好序的list。<br>2、key可以采用lambda表达式<br>3、排序的key是函数自己选择；采用key是确定排序的key，排序方式是函数自己选择。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h4&gt;&lt;p&gt;我们需要对List进行排序，Python提供了两个方法&lt;br&gt;对给定的List L进行排序，&lt;br&gt;方法1.用List的成员函数sort进行排序&lt;br&gt;方法2.用内建函数sorted进行排序（从python 2.4开始）&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.hr915.xyz/categories/python/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
    <category term="内置方法" scheme="https://www.hr915.xyz/tags/%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Restful</title>
    <link href="https://www.hr915.xyz/id_36/"/>
    <id>https://www.hr915.xyz/id_36/</id>
    <published>2018-10-03T13:32:17.000Z</published>
    <updated>2021-04-06T08:42:07.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Restful："><a href="#Restful：" class="headerlink" title="Restful："></a>Restful：</h3><p>一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><a id="more"></a><p>这么理解试试看，也就是你听过建筑的复古风格，欧美风格之类的么，大体就是一个意思。如果你盖个别墅不按设计风格走，直接以小茅屋的形式，没有属于任何风格它也能盖成不是，这就是我们平时开发API不按RESTFUL风格也可以是一个道理。REST 指的是一组架构约束条件和原则，满足这些约束条件和原则的应用程序或设计就是RESTful。</p><h4 id="Restful发展历程："><a href="#Restful发展历程：" class="headerlink" title="Restful发展历程："></a>Restful发展历程：</h4><p>详细发展历程：<a href="https://blog.csdn.net/a78270528/article/details/78469758">https://blog.csdn.net/a78270528/article/details/78469758</a><br>Restful风格==面向过程—&gt;面向资源—&gt;面向标签—&gt;面向文档</p><p>面向过程==想起一出是一出，只要有功能就写新接口</p><p>面向资源==封装单个接口，添加一个接口，删除一个接口，修改一个接口，多重逻辑需要多个if-else</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method ==POST:</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">elif</span> request.method==GET:</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><p>面向标签==封装单个接口，通过method进行语义化操作 post/put/delete/get</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>面向文档==具备面向标签的功能语义化，在返回响应的时候告诉客户还可以做什么操作</p><ul><li>说这么多，到底restful是什么？<h4 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h4></li></ul><ol><li><p>统一资源接口<br> RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p></li><li><p>URL中只使用名词来指定资源，原则上不使用动词</p></li><li><p>用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转<br> GET 用来获取资源，<br> POST 用来新建资源（也可以用于更新资源），<br> PUT 用来更新资源，<br> DELETE 用来删除资源。  </p></li><li><p>Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（on-wire data compression）。</p></li><li><p>用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</p></li></ol><h4 id="一些其他规范："><a href="#一些其他规范：" class="headerlink" title="一些其他规范："></a>一些其他规范：</h4><p>规则1：URI结尾不应包含（/）<br>规则2：正斜杠分隔符（/）必须用来指示层级关系<br>规则3：应使用连字符（ - ）来提高URI的可读性<br>规则4：不得在URI中使用下划线（_）<br>规则5：URI路径中全都使用小写字母</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Restful：&quot;&gt;&lt;a href=&quot;#Restful：&quot; class=&quot;headerlink&quot; title=&quot;Restful：&quot;&gt;&lt;/a&gt;Restful：&lt;/h3&gt;&lt;p&gt;一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Restful" scheme="https://www.hr915.xyz/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>OpenLdap</title>
    <link href="https://www.hr915.xyz/id_35/"/>
    <id>https://www.hr915.xyz/id_35/</id>
    <published>2018-10-02T13:32:17.000Z</published>
    <updated>2021-04-06T08:29:39.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是OpenLdap"><a href="#什么是OpenLdap" class="headerlink" title="什么是OpenLdap:"></a>什么是OpenLdap:</h4><p>轻型目录访问协议（英文： LightweightDirectoryAccessProtocol，缩写： LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。OpenLDAP是轻型目录访问协议（ LightweightDirectoryAccessProtocol， LDAP）的自由和开源的实现，在其 OpenLDAP许可证下发行，并已经被包含在众多流行的 Linux发行版中。</p><a id="more"></a><h4 id="为什么要用OpenLdap"><a href="#为什么要用OpenLdap" class="headerlink" title="为什么要用OpenLdap:"></a>为什么要用OpenLdap:</h4><p>可以这样讲：市面上只要你能够想像得到的所有工具软件，全部都支持 LDAP协议。<br>比如说你公司要安装一个项目管理工具，那么这个工具几乎必然支持 LDAP协议，你公司要安装一个 bug管理工具，这工具必然也支持 LDAP协议，你公司要安装一套软件版本管理工具，这工具也必然支持 LDAP协议。 LDAP协议的好处就是你公司的所有员工在所有这些工具里共享同一套用户名和密码，来人的时候新增一个用户就能自动访问所有系统，走人的时候一键删除就取消了他对所有系统的访问权限，这就是 LDAP</p><h4 id="相关概念-属性"><a href="#相关概念-属性" class="headerlink" title="相关概念(属性):"></a>相关概念(属性):</h4><table><thead><tr><th align="left">英文简称</th><th align="left">英文全称</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">DC</td><td align="left">Domain Component</td><td align="left">域名的部分，其格式是将完整的域名分成几部分，如域名为xxxx.com变成dc=xxxx,dc=com。简单理解把它理解成域名标识即可。</td></tr><tr><td align="left">OU</td><td align="left">Organization Unit</td><td align="left">组织单位，组织单位可以包含其他各种对象，如“开发组”（一条记录的所属组织）。简单理解把他理解成公司的组织和部门：ou=开发一组，ou=技术研发部门</td></tr><tr><td align="left">UID</td><td align="left">User Id</td><td align="left">用户ID zhangsan（一条记录的ID）</td></tr><tr><td align="left">DN</td><td align="left">Distinguished Name</td><td align="left">“uid=zhangsan,ou=开发一组，ou=技术研发部门,dc=xxxx,dc=com”，一条记录的位置（唯一） DN的元素包含UID（或CN) + OU + DC</td></tr><tr><td align="left">CN</td><td align="left">Common Name</td><td align="left">公共名称，如“张三”（一条记录的名称）。简单理解用于描述UID的</td></tr><tr><td align="left">rdn</td><td align="left">Relative dn</td><td align="left">相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid=zhangsan”或“cn= 张三”</td></tr><tr><td align="left">SN</td><td align="left">Surname</td><td align="left">姓，如“张”</td></tr></tbody></table><h5 id="DN"><a href="#DN" class="headerlink" title="DN:"></a>DN:</h5><p>LDAP连接服务器的连接字串格式为：ldap://servername/DN  </p><p>其中DN有三个属性，分别是CN,OU,DC  </p><p>CN, OU, DC 都是 LDAP 连接服务器的端字符串中的区别名称（DN, distinguished  name） </p><p>LDAP是一种通讯协议，如同HTTP是一种协议一样的！ </p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是OpenLdap&quot;&gt;&lt;a href=&quot;#什么是OpenLdap&quot; class=&quot;headerlink&quot; title=&quot;什么是OpenLdap:&quot;&gt;&lt;/a&gt;什么是OpenLdap:&lt;/h4&gt;&lt;p&gt;轻型目录访问协议（英文： LightweightDirectoryAccessProtocol，缩写： LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。OpenLDAP是轻型目录访问协议（ LightweightDirectoryAccessProtocol， LDAP）的自由和开源的实现，在其 OpenLDAP许可证下发行，并已经被包含在众多流行的 Linux发行版中。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="OpenLdap" scheme="https://www.hr915.xyz/tags/OpenLdap/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉树</title>
    <link href="https://www.hr915.xyz/id_34/"/>
    <id>https://www.hr915.xyz/id_34/</id>
    <published>2018-09-30T13:32:17.000Z</published>
    <updated>2021-04-06T00:28:40.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>简单的三种数据结构：</p><p><img src="/id_34/1.png" alt="数据结构"></p><a id="more"></a><p>树：由一个根节点分出许多子节点，最终的节点叫做叶子节点</p><p>二叉树：每一个节点都会生出两个子节点(左节点or右节点)，最终的节点叫做叶子节点</p><p>栈和队列想查询某个元素只有遍历查询，而树每个节点之间都有关联，便于高效查询</p><p>查询效率第一位的时候需要用到树结构</p><h4 id="遍历方式："><a href="#遍历方式：" class="headerlink" title="遍历方式："></a>遍历方式：</h4><p>树遍历的三种方式：前序遍历，中序遍历，后序遍历</p><ul><li>前序遍历 从根节点开始输出—&gt;左节点输出，继续向下左节点输出，直到叶子节点—&gt;右节点输出—&gt;   简单来说: 根—&gt;左—&gt;右</li><li>中序遍历 先找左子树，找到叶子结点输出—&gt;上一级输出—-&gt;右节点的左叶子结点输出—&gt;上一级输出—右节点的左叶子节点输出—&gt;  简单来说: 左—&gt;根—&gt;右</li><li>后序遍历 从子节点的左/右叶子节点，开始输出—&gt;右节点输出—&gt;上级节点—&gt;   简单来说: 左—&gt;右—&gt;根</li></ul><p>举个例子:<br><img src="/id_34/%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86.png" alt="数据结构"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.data = <span class="literal">None</span></span><br><span class="line">        self.lis = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preface</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">'''先序'''</span></span><br><span class="line">        self.lis.append(node.data)</span><br><span class="line">        <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">            self.preface(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">            self.preface(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleorder</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">'''中序'''</span></span><br><span class="line">        <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">            self.middleorder(node.left)</span><br><span class="line"></span><br><span class="line">        self.lis.append(node.data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">            self.middleorder(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postscript</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">'''后序'''</span></span><br><span class="line">        <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">            self.postscript(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">            self.postscript(node.right)</span><br><span class="line"></span><br><span class="line">        self.lis.append(node.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, node, lis, data</span>):</span></span><br><span class="line">        <span class="string">'''查找'''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left == <span class="literal">None</span>:</span><br><span class="line">            lis = self.search(node.left, lis, data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            lis = self.search(node.right, lis, data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lis != []:</span><br><span class="line">            <span class="comment"># 判断当前节点是否在查询节点的线上</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> lis[-<span class="number">1</span>] == node.left.data:</span><br><span class="line">                    lis.append(node.data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> lis[-<span class="number">1</span>] == node.right.data:</span><br><span class="line">                    lis.append(node.data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.data == data:</span><br><span class="line">            lis.append(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = Tree()</span><br><span class="line"></span><br><span class="line">    root.data = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">    root.left = Tree()</span><br><span class="line">    root.left.data = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">    root.right = Tree()</span><br><span class="line">    root.right.data = <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">    root.left.left = Tree()</span><br><span class="line">    root.left.left.data = <span class="string">'4'</span></span><br><span class="line"></span><br><span class="line">    root.left.right = Tree()</span><br><span class="line">    root.left.right.data = <span class="string">'5'</span></span><br><span class="line"></span><br><span class="line">    root.right.left = Tree()</span><br><span class="line">    root.right.left.data = <span class="string">'6'</span></span><br><span class="line"></span><br><span class="line">    root.right.right = Tree()</span><br><span class="line">    root.right.right.data = <span class="string">'7'</span></span><br><span class="line"></span><br><span class="line">    root.left.left.left = Tree()</span><br><span class="line">    root.left.left.left.data = <span class="string">'8'</span></span><br><span class="line"></span><br><span class="line">    root.left.right.left = Tree()</span><br><span class="line">    root.left.right.left.data = <span class="string">'9'</span></span><br><span class="line"></span><br><span class="line">    root.right.left.right = Tree()</span><br><span class="line">    root.right.left.right.data = <span class="string">'10'</span></span><br><span class="line"></span><br><span class="line">    root.right.right.right = Tree()</span><br><span class="line">    root.right.right.right.data = <span class="string">'11'</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'先序:'</span>)</span><br><span class="line">    root.lis = []</span><br><span class="line">    root.preface(root)</span><br><span class="line">    print(root.lis)</span><br><span class="line">    print(<span class="string">'中序:'</span>)</span><br><span class="line">    root.lis = []</span><br><span class="line">    root.middleorder(root)</span><br><span class="line">    print(root.lis)</span><br><span class="line">    print(<span class="string">'后序:'</span>)</span><br><span class="line">    root.lis = []</span><br><span class="line">    root.postscript(root)</span><br><span class="line">    print(root.lis)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;简单的三种数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/id_34/1.png&quot; alt=&quot;数据结构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树" scheme="https://www.hr915.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>周期总结</title>
    <link href="https://www.hr915.xyz/id_30/"/>
    <id>https://www.hr915.xyz/id_30/</id>
    <published>2018-09-07T13:46:25.000Z</published>
    <updated>2021-03-29T08:27:01.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>转眼一个周期过去了，学了很多零碎的知识点。有遇到困难，有得到解惑。</p><a id="more"></a><p>day01: 在vue中使用ant_design<br>ant_design+vue官方文档：<a href="https://antdv.com/docs/vue/introduce-cn/">https://antdv.com/docs/vue/introduce-cn/</a></p><p>day02: IT新闻资讯<br>网址: <a href="https://www.cnbeta.com/">https://www.cnbeta.com/</a></p><p>day03: redis实现输入密码错误五次封禁账号<br>移步: <a href="https://www.hr915.xyz/id_20/">https://www.hr915.xyz/id_20/</a></p><p>day04: httpx编写测试脚本<br>移步: <a href="https://www.hr915.xyz/id_6/">https://www.hr915.xyz/id_6/</a></p><p>day05: 异步任务队列<br>移步: <a href="https://www.hr915.xyz/id_19/">https://www.hr915.xyz/id_19/</a></p><p>day06: 加权队列<br>移步: <a href="https://www.hr915.xyz/id_21/">https://www.hr915.xyz/id_21/</a></p><p>day07: 异步消费<br>移步: <a href="https://www.hr915.xyz/id_22/">https://www.hr915.xyz/id_22/</a></p><p>day08: 权限模型</p><p>day09: 三方登录<br>移步: <a href="https://www.hr915.xyz/id_13/">https://www.hr915.xyz/id_13/</a></p><p>day10: 位运算<br>移步: <a href="https://www.hr915.xyz/id_23/">https://www.hr915.xyz/id_23/</a></p><p>day11: 工单分类</p><p>day12: Mongodb<br>移步: <a href="https://www.hr915.xyz/id_24/">https://www.hr915.xyz/id_24/</a></p><p>day13: 审批流程</p><p>day14: 栈的使用<br>移步: <a href="https://www.hr915.xyz/id_25/">https://www.hr915.xyz/id_25/</a></p><p>day15: 设计模式<br>移步: <a href="https://www.hr915.xyz/id_26/">https://www.hr915.xyz/id_26/</a></p><p>day16: 消息盒子</p><p>day17: websocket<br>移步: <a href="https://www.hr915.xyz/id_10/">https://www.hr915.xyz/id_10/</a></p><p>day18: 客服系统</p><p>day19: 部署</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;转眼一个周期过去了，学了很多零碎的知识点。有遇到困难，有得到解惑。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://www.hr915.xyz/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>分代回收</title>
    <link href="https://www.hr915.xyz/id_29/"/>
    <id>https://www.hr915.xyz/id_29/</id>
    <published>2018-09-05T13:46:25.000Z</published>
    <updated>2021-03-29T08:27:01.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>标记-清除会在大规模遍历内存中会使程序暂停 ，程序暂停会导致我们程序出现很多我们意想不到的错误和问题出现，所以pyt hon引入了我们的分代回收来解决这个问题，分代回收也应该是我们在面试过程中主动向面试官阐述出来的。</p><a id="more"></a><h4 id="分代回收原理："><a href="#分代回收原理：" class="headerlink" title="分代回收原理："></a>分代回收原理：</h4><p>分代回收主要是将我们的内存根据对象的时候或被标记的次数进行分代他是一种典型是<strong>时间换空间</strong>的行为，那么他主要分为三代，<strong>青年代</strong>、<strong>中年代</strong>、<strong>老年代</strong>。那么我们可以认为一个对象在内存中存在的时间越长，越不容易被回收，越不是一个垃圾，这里我们认为<strong>老年代</strong>是存活在三代中最长的，那也是最不容易被回收掉的。</p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>那么我们可以来看一下，假设下图是一块内存： </p><p><img src="/id_29/01.png" alt="内存"></p><p>那我们现在有一个变量a=1首先进入青年代，然后陆陆续续的我们会有变量存入青年代之后，青年代觉得他自己快要满了，那么此时会触发我们的标记清除动作。</p><p><img src="/id_29/02.png" alt="青年代"></p><p>那么触发我们的回收机制，标记-清除之后会在青年代中找到所有引用计数为0的元素，并将其释放。把剩余可以继续往下的元素沉淀到中年代，那么这就是分代回收的技术。</p><p><img src="/id_29/03.png" alt="沉淀中年代"></p><p>他是结合了我们引用计数和标记清除在内的，那每一次对比于之前，现在我们标记清除不需要遍历整段内存，只需要将其对应代遍历即可，那么这样就间接节约了我们遍历所花费的暂停时间，让我们的程序尽可能不要的过多整段内存去遍历，去过滤。</p><p>那么当然呢，更加细节的来说：</p><ul><li>其实是在我们的第0代，也就是青年代满的时候呢将会触发清理我们所有的三代，</li><li>而在中年代满时，将会触发清理我们的中年代和老年代，</li><li>而在我们老年代满的时候呢，只会触发清理我们的老年代，</li><li>也就是说呢，每一层在满了之后，他就会触发<strong>当前及当前之后的每代</strong>的回收动作，</li></ul><p><strong>目的</strong>：那么分代回收他的主要目的是为了解决我们标记-清除所带来的一些额外操作，我们上一节也说过，标记-清除如果需要遍历的内存节点较多的时候，那么每一次回收他都要花费大量的时间，那么利用我们的分代回收就可以减少这些情况</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们python管理内存是以引用计数为主，标记清除和分代回收为辅的方法来管理内存的</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;分代回收&quot;&gt;&lt;a href=&quot;#分代回收&quot; class=&quot;headerlink&quot; title=&quot;分代回收&quot;&gt;&lt;/a&gt;分代回收&lt;/h3&gt;&lt;p&gt;标记-清除会在大规模遍历内存中会使程序暂停 ，程序暂停会导致我们程序出现很多我们意想不到的错误和问题出现，所以pyt hon引入了我们的分代回收来解决这个问题，分代回收也应该是我们在面试过程中主动向面试官阐述出来的。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制之标记-清除</title>
    <link href="https://www.hr915.xyz/id_28/"/>
    <id>https://www.hr915.xyz/id_28/</id>
    <published>2018-09-05T12:46:23.000Z</published>
    <updated>2021-04-06T07:02:33.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>垃圾自动回收机制的出现使编程更加的简单，使得我们不需要再去考虑内存分配和释放的问题，而是更加的专注在我们产品功能的实现上</p><p>目前最基本的垃圾收集算法有四种,标记-清除算法(mark-sweep),标记-压缩算法(mark-compact),复制算法(copying)以及引用计数算法(reference counting).而现代流行的垃圾收集算法一般是由这四种中的其中几种算法相互组合而成，比如说，对堆(heap)的一部分采用标记-清除算法，对堆(heap)的另外一部分则采用复制算法等等。今天我们主要来看下标记-清除算法的原理。</p><a id="more"></a><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>标记-清除算法分为两个阶段，标记(mark)和清除(sweep)</p><h5 id="标记："><a href="#标记：" class="headerlink" title="标记："></a>标记：</h5><p>在内存中对每一个被使用到的变量来进行标记</p><p>标记是从根对象开始工作，所有能够和根对象联系的变量我们都会有相应的标记。</p><h5 id="标记举例"><a href="#标记举例" class="headerlink" title="标记举例"></a>标记举例</h5><p><img src="/id_28/01.png" alt="标记"></p><p><img src="/id_28/02.png" alt="标记"></p><p><img src="/id_28/03.png" alt="标记"></p><h5 id="清除"><a href="#清除" class="headerlink" title="清除:"></a>清除:</h5><p>清除主要是将内存中无关联根对象的并且没有被标记的变量给杀死，释放掉</p><p><img src="/id_28/04.png" alt="image-20210324190403266"></p><p>图中a和b已经和根对象没有关系了，而且并没有被标记，所以就会被清除掉</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>总的来说，在标记-清除过程中,他会扫描整个内存空间，扫描过程中python程序会暂停，被标记的对象不会被回收，没有标记的对象会被回收掉。<br>但是我们整个python程序暂停，暂停会导致程序无法正常运行，让程序运行时出现一些问题从而造成程序阻塞问题<br>那python呢就引入了<strong>分代回收</strong>来避免标记-清除，由于每一次过程都需要去大量的遍历整块内存而造成的程序阻塞问题</p><p>分代回收参考下一篇文章：<a href="https://www.hr915.xyz/id_29">https://www.hr915.xyz/id_29</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;垃圾回收机制&quot;&gt;&lt;a href=&quot;#垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收机制&quot;&gt;&lt;/a&gt;垃圾回收机制&lt;/h3&gt;&lt;p&gt;垃圾自动回收机制的出现使编程更加的简单，使得我们不需要再去考虑内存分配和释放的问题，而是更加的专注在我们产品功能的实现上&lt;/p&gt;
&lt;p&gt;目前最基本的垃圾收集算法有四种,标记-清除算法(mark-sweep),标记-压缩算法(mark-compact),复制算法(copying)以及引用计数算法(reference counting).而现代流行的垃圾收集算法一般是由这四种中的其中几种算法相互组合而成，比如说，对堆(heap)的一部分采用标记-清除算法，对堆(heap)的另外一部分则采用复制算法等等。今天我们主要来看下标记-清除算法的原理。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>引用计数</title>
    <link href="https://www.hr915.xyz/id_27/"/>
    <id>https://www.hr915.xyz/id_27/</id>
    <published>2018-09-05T12:43:25.000Z</published>
    <updated>2021-04-12T01:37:01.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><h5 id="问"><a href="#问" class="headerlink" title="问"></a>问</h5><p>引用计数这个问题是我们在面试中经常会遇到的。通常面试官会这样问：</p><ol><li>python中是如何管理内存的？</li><li>你知道引用计数吗？<a id="more"></a></li></ol><h5 id="答"><a href="#答" class="headerlink" title="答"></a>答</h5><p>引用计数是内存管理机制，将资源的使用次数保存起来，在引用次数变为<strong>零</strong>时进行释放</p><p>比如说我们现在有一个变量a，指向内存中的字符 ‘x’ ，此时x在内存中的引用计数为1，然后又有一个变量b，b=a</p><p>此时(b=a)和(a=’x’)是相等的，那这个时候x在内存中的引用计数就会+1变为2</p><p><img src="/id_27/%E4%BE%8B.png" alt="案例"></p><h4 id="引用计数的好处"><a href="#引用计数的好处" class="headerlink" title="引用计数的好处"></a>引用计数的好处</h4><p>我们可以举一些生活中的场景，比如说我们出去<strong>旅游</strong>，朋友提前抵达并开好了房间，这样我们就可以免费跟朋友住一间房，这样既节约了我们的时间，又节约了我们另外开房需要支付的资金。</p><ul><li>可知：减少了内存碎片的产生，</li><li>并且可以对于我们在创建和释放内存中有一定的资源开销的节省。</li><li>可以更快的进行资源管理</li></ul><p>那同样，当我们旅途结束，不需要再居住的时候，所有人离开酒店，那这个房间就会被酒店的人员进行清理，处理。</p><ul><li>这样就像引用计数中计数为0时，内存会被回收掉是一样的</li></ul><h4 id="查看引用计数"><a href="#查看引用计数" class="headerlink" title="查看引用计数"></a>查看引用计数</h4><p>查看引用计数我们是使用了sys模块中getrefcount方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Lenovo&gt;python.exe</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.0</span> (v3<span class="number">.7</span><span class="number">.0</span>:1bf9cc5093, Jun <span class="number">27</span> <span class="number">2018</span>, 04:<span class="number">59</span>:<span class="number">51</span>) [MSC v<span class="number">.1914</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">119</span></span><br><span class="line"><span class="comment"># 得出常量1在内存中的引用计数为119</span></span><br></pre></td></tr></tbody></table></figure><h4 id="那什么时候会用到引用计数呢"><a href="#那什么时候会用到引用计数呢" class="headerlink" title="那什么时候会用到引用计数呢"></a>那什么时候会用到引用计数呢</h4><p>当发生以下四种情况的时候，该对象的引用计数器+1</p><p>对象被创建 a=14<br>对象被引用 b=a<br>对象被作为参数,传到函数中 func(a)<br>对象作为一个元素，存储在容器中  List={a,”a”,”b”,2}</p><h5 id="取两点举例："><a href="#取两点举例：" class="headerlink" title="取两点举例："></a>取两点举例：</h5><p>1、 变量互相赋值的时候</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'x'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">3242716434928</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">3242716434928</span></span><br><span class="line"><span class="comment"># 此时我们可以看出两个变量指向的内存地址是完全一样的 。可得变量互相赋值的时候用到了引用计数</span></span><br></pre></td></tr></tbody></table></figure><p>2、常用对象创建时</p><p>python本身含有a-z,A-Z,0-9等常见值的引用</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140707666383904</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140707666383904</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">140707666383904</span></span><br><span class="line"><span class="comment"># 此时我们可以看出a,b,c的内存地址都是完全一致的， 可得常用对象创建时用到了引用计数</span></span><br></pre></td></tr></tbody></table></figure><h4 id="如何减少引用次数"><a href="#如何减少引用次数" class="headerlink" title="如何减少引用次数"></a>如何减少引用次数</h4><p>与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1</p><p>当该对象的别名被显式销毁时 del a<br>当该对象的引别名被赋予新的对象，  a=26<br>一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）<br>将该元素从容器中删除时，或者容器被销毁时。</p><p>.当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁</p><p>有两点</p><p>1、变量被重新赋值为别的值</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="comment"># 可以看出，当a被重新赋值后再次查看1的引用计数是减少了1的</span></span><br></pre></td></tr></tbody></table></figure><p>2、del  删除变量</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(<span class="number">1</span>)</span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="comment"># 可以看出，当a被del删除后再次查看1的引用计数是减少了1的</span></span><br></pre></td></tr></tbody></table></figure><h4 id="引用计数的缺点"><a href="#引用计数的缺点" class="headerlink" title="引用计数的缺点"></a>引用计数的缺点</h4><p>那引用计数真的这么完美吗，不占内存地址，用完即释放，nonono,当然不是</p><p>引用计数最大的缺点就是<strong>循环引用</strong></p><p>那循环引用是什么呢？</p><p>循环引用就是两个变量互相引用时假设已经被释放，但引用计数不为0，那就会导致这两个变量无法被直接回收</p><p><strong>那循环引用有什么解决办法吗？</strong></p><p>那肯定是有的，python中解决循环引用的方法就是<strong>标记-清除</strong><br>请移步下一节：<a href="https://www.hr915.xyz/id_28">https://www.hr915.xyz/id_28</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h3&gt;&lt;h5 id=&quot;问&quot;&gt;&lt;a href=&quot;#问&quot; class=&quot;headerlink&quot; title=&quot;问&quot;&gt;&lt;/a&gt;问&lt;/h5&gt;&lt;p&gt;引用计数这个问题是我们在面试中经常会遇到的。通常面试官会这样问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;python中是如何管理内存的？&lt;/li&gt;
&lt;li&gt;你知道引用计数吗？&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://www.hr915.xyz/id_26/"/>
    <id>https://www.hr915.xyz/id_26/</id>
    <published>2018-09-04T12:46:25.000Z</published>
    <updated>2021-03-29T08:27:01.231Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h4><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p><h4 id="设计模式有三大类："><a href="#设计模式有三大类：" class="headerlink" title="设计模式有三大类："></a>设计模式有三大类：</h4><ol><li>创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。</li><li>结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。</li><li>行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。</li></ol><a id="more"></a><p><strong>创建型</strong></p><ol><li><p>Factory Method（工厂方法）</p></li><li><p>Abstract Factory（抽象工厂）</p></li><li><p>Builder（建造者）</p></li><li><p>Prototype（原型）</p></li><li><p>Singleton（单例）</p></li></ol><p><strong>结构型</strong></p><ol start="6"><li><p>Adapter Class/Object（适配器）</p></li><li><p>Bridge（桥接）</p></li><li><p>Composite（组合）</p></li><li><p>Decorator（装饰）</p></li><li><p>Facade（外观）</p></li><li><p>Flyweight（享元）</p></li><li><p>Proxy（代理）</p></li></ol><p><strong>行为型</strong></p><ol start="13"><li><p>Interpreter（解释器）</p></li><li><p>Template Method（模板方法）</p></li><li><p>Chain of Responsibility（责任链）</p></li><li><p>Command（命令）</p></li><li><p>Iterator（迭代器）</p></li><li><p>Mediator（中介者）</p></li><li><p>Memento（备忘录）</p></li><li><p>Observer（观察者）</p></li><li><p>State（状态）</p></li><li><p>Strategy（策略）</p></li><li><p>Visitor（访问者）</p></li></ol><ul><li><h4 id="这里我们挑两个做例子"><a href="#这里我们挑两个做例子" class="headerlink" title="这里我们挑两个做例子"></a>这里我们挑两个做例子</h4></li></ul><p><strong>１．Factory Method（工厂方法）</strong></p><p>意图：</p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p>适用性：</p><p>当一个类不知道它所必须创建的对象的类的时候。</p><p>当一个类希望由它的子类来指定它所创建的对象的时候。</p><p>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 </p><p><img src="/id_26/%E5%B7%A5%E5%8E%82.png" alt="工厂模式"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="comment"># 用于显示，return的数据repr会自动帮你打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'小汽车'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 口罩</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mask</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"口罩"</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span>:</span></span><br><span class="line">    <span class="comment"># 装饰器  静态方法</span></span><br><span class="line">    <span class="comment"># 类方法需用用类实例调用。静态方法不需要类实例，直接通过类名就可以调用</span></span><br><span class="line">    <span class="comment"># product 产品</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">"小汽车"</span>:</span><br><span class="line">            <span class="keyword">return</span> Car()</span><br><span class="line">        <span class="keyword">elif</span> name == <span class="string">'口罩'</span>:</span><br><span class="line">            <span class="keyword">return</span> Mask()</span><br><span class="line"></span><br><span class="line">print(SimpleFactory.product(<span class="string">'小汽车'</span>))</span><br><span class="line">print(SimpleFactory.product(<span class="string">"口罩"</span>))</span><br></pre></td></tr></tbody></table></figure><p><strong>2. Singleton（单例）</strong><br>意图：</p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>适用性：</p><p>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</p><p>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p><img src="/id_26/%E5%8D%95%E4%BE%8B.png" alt="单例模式"></p><p>实现：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            org = <span class="built_in">super</span>(Singleton, cls)</span><br><span class="line">            cls._instance = org.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SingleSpam</span>(<span class="params">Singleton</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, s</span>):</span></span><br><span class="line">            self.s = s</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.s</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    s1 = SingleSpam(<span class="string">'spam'</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">id</span>(s1), s1</span><br><span class="line">    s2 = SingleSpam(<span class="string">'spa'</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">id</span>(s2), s2</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">id</span>(s1), s1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h4&gt;&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
&lt;h4 id=&quot;设计模式有三大类：&quot;&gt;&lt;a href=&quot;#设计模式有三大类：&quot; class=&quot;headerlink&quot; title=&quot;设计模式有三大类：&quot;&gt;&lt;/a&gt;设计模式有三大类：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。&lt;/li&gt;
&lt;li&gt;结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。&lt;/li&gt;
&lt;li&gt;行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="python" scheme="https://www.hr915.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>栈的使用</title>
    <link href="https://www.hr915.xyz/id_25/"/>
    <id>https://www.hr915.xyz/id_25/</id>
    <published>2018-09-03T12:46:25.000Z</published>
    <updated>2021-04-01T03:27:48.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈（stack）又名堆栈，它是一种运算受限的<strong>线性表</strong>。限定仅在表尾进行插入和删除操作的线性表。<br>这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；<br>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><a id="more"></a><p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。<br>它按照<strong>先进后出</strong>，<strong>后进先出</strong>的原则存储数据</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>银行ATM自动存取款机<br>  假设取款机下有一个用来钱的箱子，箱子只有一个口供用户存取现金<br>  当你存钱的时候，ATM会把钱放在最上面<br>  当你取钱的时候，ATM会把最上面的钱吐出来</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="将十进制的数转换为二进制的数"><a href="#将十进制的数转换为二进制的数" class="headerlink" title="将十进制的数转换为二进制的数"></a>将十进制的数转换为二进制的数</h5><p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为二进制，将十进制数除以2，记录余数，然后继续将商除以2，一直到商等于0为止，最后将余数倒着写数来就可以了。</p><p>比如13的二进制，13首先除以2商6余1,1首先进栈，然后6除以2商3余0，第二个余数0进栈，接着3除以2，商1余1，第三个余数1进栈，继续1除以2商0余1，第四个余数1进栈。最后将四个余数出栈，就得到了13的二进制1101。<br>实现代码如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.item = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        self.item.append(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.item) != <span class="number">0</span>:</span><br><span class="line">                print(self.item.pop(),end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exe</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        key = <span class="built_in">int</span>(key)</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            self.push(key % <span class="number">2</span>)</span><br><span class="line">            key //= <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> key == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Stack()</span><br><span class="line">s.exe(<span class="built_in">input</span>(<span class="string">"请输入您要进行换算的数字："</span>))</span><br><span class="line">s.pop()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="栈和队列的异同点"><a href="#栈和队列的异同点" class="headerlink" title="栈和队列的异同点"></a>栈和队列的异同点</h3><h4 id="首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。"><a href="#首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。" class="headerlink" title="首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。"></a>首先，栈（Stack）和队列（Queue）是两种操作受限的线性表。</h4><h4 id="栈与队列的相同点："><a href="#栈与队列的相同点：" class="headerlink" title="栈与队列的相同点："></a>栈与队列的相同点：</h4><p>1.都是线性结构。<br>2.插入操作都是限定在表尾进行。<br>3.都可以通过顺序结构和链式结构实现。<br>4.插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。<br>5.多链栈和多链队列的管理模式可以相同。</p><h4 id="栈与队列的不同点："><a href="#栈与队列的不同点：" class="headerlink" title="栈与队列的不同点："></a>栈与队列的不同点：</h4><p>1.删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。<br>2.应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。<br>3.顺序栈能够实现多栈空间共享，而顺序队列不能。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;栈（stack）又名堆栈，它是一种运算受限的&lt;strong&gt;线性表&lt;/strong&gt;。限定仅在表尾进行插入和删除操作的线性表。&lt;br&gt;这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；&lt;br&gt;从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="进制" scheme="https://www.hr915.xyz/tags/%E8%BF%9B%E5%88%B6/"/>
    
    <category term="栈" scheme="https://www.hr915.xyz/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB安装与使用</title>
    <link href="https://www.hr915.xyz/id_24/"/>
    <id>https://www.hr915.xyz/id_24/</id>
    <published>2018-09-02T12:46:25.000Z</published>
    <updated>2021-03-29T08:27:01.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h4><p>MongoDB安装方式</p><ul><li>将MongoDB服务下载下来 安装到自己的电脑<a id="more"></a><h5 id="MongoDB服务下载并安装"><a href="#MongoDB服务下载并安装" class="headerlink" title="MongoDB服务下载并安装"></a>MongoDB服务下载并安装</h5></li></ul><p>进入<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a> 这个链接去下载，<br>下载完成后，会得到一个后缀为.msi的文件，双击进行安装即可<br><strong>注意</strong>：不去掉勾选的话可能会安装特别慢，四五个小时都有可能<br><img src="/id_24/01.jpg" alt="注意"><br>详细安装过程可参考菜鸟教程<br><a href="https://www.runoob.com/mongodb/mongodb-window-install.html">https://www.runoob.com/mongodb/mongodb-window-install.html</a></p><h5 id="MongoDB-Compass（可视化工具）安装"><a href="#MongoDB-Compass（可视化工具）安装" class="headerlink" title="MongoDB Compass（可视化工具）安装"></a>MongoDB Compass（可视化工具）安装</h5><p>进入 <a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a> 这个链接下载可视化工具<br>下载完成后，会得到一个压缩文件，解压到任意文件夹里即可，<br>压缩包解压之后，上方有一个MongoDBCompass.exe文件，打开即可</p><p>MongoDB使用</p><p>基本语法</p><table><thead><tr><th>命令</th><th>语法</th></tr></thead><tbody><tr><td>创建数据库</td><td>use 数据库名</td></tr><tr><td>展示所有数据库</td><td>show dbss</td></tr><tr><td>查看当前所在数据库</td><td>db</td></tr><tr><td>创建集合</td><td>db.createCollection(‘集合’)</td></tr><tr><td>展示集合</td><td>show 集合名</td></tr><tr><td>插入数据</td><td>db.集合.insert({…})</td></tr><tr><td>读取数据</td><td>db.集合.find()</td></tr><tr><td>读取指定数据</td><td>db.集合.find({id:1})</td></tr><tr><td>读取一条数据</td><td>db.集合.find_one({id:1})</td></tr></tbody></table><h4 id="python操作MongoDB"><a href="#python操作MongoDB" class="headerlink" title="python操作MongoDB"></a>python操作MongoDB</h4><ul><li>下载python中的MongoDB<blockquote><p>pip install pymongo</p></blockquote></li></ul><p>下载完成之后，进行连接（此处要导包）</p><blockquote><p>from pymongo import MongoClient<br>client = MongoClient(host=’127.0.0.1’, port=27017)</p></blockquote><p>接下来需要进入我们在MongoDB创建的数据库(mongotest)<br>此处没有创建数据库的，需要手动创建MongoDB数据库（看上方的基本语法）</p><blockquote><p>db = client.mongotest</p></blockquote><p>指定集合</p><blockquote><p>table = db.CateTemplate</p></blockquote><p>建立好之后，就可以进行查询了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">    <span class="comment"># 进入数据库</span></span><br><span class="line">    db = client.mongotest</span><br><span class="line">    <span class="comment"># 集合</span></span><br><span class="line">    dbset = db.CateTemplate</span><br><span class="line">    <span class="built_in">id</span> = request.GET.get(<span class="string">'id'</span>, <span class="literal">None</span>)</span><br><span class="line">    tid = WorkOrderModel.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="built_in">id</span>).first()</span><br><span class="line">    data = {}</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> zst.find({<span class="string">'tid'</span>: <span class="built_in">str</span>(tid.pid)}):</span><br><span class="line">        data = <span class="built_in">eval</span>(i[<span class="string">'name'</span>])</span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></tbody></table></figure><h4 id="OK"><a href="#OK" class="headerlink" title="OK"></a>OK</h4>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;MongoDB安装&quot;&gt;&lt;a href=&quot;#MongoDB安装&quot; class=&quot;headerlink&quot; title=&quot;MongoDB安装&quot;&gt;&lt;/a&gt;MongoDB安装&lt;/h4&gt;&lt;p&gt;MongoDB安装方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将MongoDB服务下载下来 安装到自己的电脑&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mongodb" scheme="https://www.hr915.xyz/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://www.hr915.xyz/id_23/"/>
    <id>https://www.hr915.xyz/id_23/</id>
    <published>2018-08-29T02:52:38.000Z</published>
    <updated>2021-03-29T08:27:01.271Z</updated>
    
    <content type="html"><![CDATA[<p>位运算是一切算法的基础<br>位运算是对二进制进行操作<br>使用位运算来判断奇偶数的时候效率要快一些，性能会高一些，因为二进制是计算机识别的语言，计算机不需要去强转然后判断，直接判断即可<br>例如；判断4是不是奇数或偶数</p><a id="more"></a><p>可以二进制直接和1进行比较<br>0b100 &amp; 1<br>0<br>也可以使用十进制直接和1比较<br>4 &amp; 1<br>0</p><blockquote><p> 返回为0 证明是偶数</p></blockquote><p>0b11 &amp; 1<br>1<br>3 &amp; 1<br>1</p><blockquote><p>返回为1 证明是奇数 </p></blockquote><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>符号    描述    运算规则<br>&amp;    与    两个位都为1时，结果才为1<br>|    或    两个位都为0时，结果才为0<br>^    异或    两个位相同为0，相异为1<br>~    取反    0变1，1变0</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;位运算是一切算法的基础&lt;br&gt;位运算是对二进制进行操作&lt;br&gt;使用位运算来判断奇偶数的时候效率要快一些，性能会高一些，因为二进制是计算机识别的语言，计算机不需要去强转然后判断，直接判断即可&lt;br&gt;例如；判断4是不是奇数或偶数&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="进制" scheme="https://www.hr915.xyz/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>异步消费</title>
    <link href="https://www.hr915.xyz/id_22/"/>
    <id>https://www.hr915.xyz/id_22/</id>
    <published>2018-08-28T11:34:15.000Z</published>
    <updated>2021-03-29T08:27:01.242Z</updated>
    
    <content type="html"><![CDATA[<p>异步消费可以使用很多方式来实现，我们今天就来说说异步消费的其中三种实现方式:</p><ul><li>多线程</li><li>线程池</li><li>协程<a id="more"></a></li></ul><h4 id="首先，将封装的代码及逻辑写上"><a href="#首先，将封装的代码及逻辑写上" class="headerlink" title="首先，将封装的代码及逻辑写上"></a>首先，将封装的代码及逻辑写上</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="comment"># 队列遵循先进先出的原则</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, **redis_kwargs</span>):</span></span><br><span class="line">        <span class="comment"># **kwarys不定长参数  用于可传可不传的参数 </span></span><br><span class="line">        <span class="comment"># kwargs是用来传键值对，args 一般用来传列表和元祖</span></span><br><span class="line">        <span class="comment"># self.__变量名：使用双下划线开头的变量是私有变量，在类外不可以被调用</span></span><br><span class="line">        <span class="comment"># redis的默认参数为：host='localhost', port=6379, db=0， 其中db为定义redis的第几个库</span></span><br><span class="line">        self.__db = redis.Redis(**redis_kwargs, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.key = name</span><br><span class="line">        <span class="comment"># llen:获取列表长度</span></span><br><span class="line">        <span class="comment"># lrange:获取列表指定范围内的元素</span></span><br><span class="line">        self.r_len = self.__db.llen(self.key)</span><br><span class="line">        self.l = self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">tuple</span></span>):</span></span><br><span class="line">        <span class="comment"># rpush:在列表中添加一个或多个值</span></span><br><span class="line">        self.__db.rpush(self.key, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 排序用来加权(加权是celery没有的)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 因为redis里存的是字符串，而排序的依据是元组中最后一个元素为int,所以使用-2下标</span></span><br><span class="line">        <span class="comment"># 此处可用eval </span></span><br><span class="line">        self.l = <span class="built_in">sorted</span>(self.l, key=<span class="keyword">lambda</span> x: x[-<span class="number">2</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># pop(0):移出并获取列表的第一个元素</span></span><br><span class="line">        <span class="comment"># lrem 根据第二个参数的值，移除列表中与参数相等的元素。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.l:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        item = self.l.pop(<span class="number">0</span>)</span><br><span class="line">        self.__db.lrem(self.key, item, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 用来清空列表</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.delete(self.key)</span><br><span class="line"></span><br><span class="line">q = MyQueue(<span class="string">"que"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    q.push((i, i + <span class="number">1</span>, i + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dojob</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        result = q.pop()</span><br><span class="line">        <span class="comment"># 写逻辑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(result)</span><br></pre></td></tr></tbody></table></figure><h4 id="使用多线程实现异步消费"><a href="#使用多线程实现异步消费" class="headerlink" title="使用多线程实现异步消费"></a>使用多线程实现异步消费</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 创建三个线程</span></span><br><span class="line">    thread = threading.Thread(target=dojob) <span class="comment">#调用任务</span></span><br><span class="line">    thread.start() <span class="comment"># 开启线程</span></span><br><span class="line">print(q.r_len)</span><br></pre></td></tr></tbody></table></figure><h4 id="使用线程池实现异步消费"><a href="#使用线程池实现异步消费" class="headerlink" title="使用线程池实现异步消费"></a>使用线程池实现异步消费</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 设置线程数最大为5</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> t:</span><br><span class="line">        [t.submit(dojob) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对iterables执行map处理</span></span><br><span class="line">        <span class="comment"># 可以通过submit提交执行的函数到线程池中</span></span><br><span class="line"><span class="comment"># 线程池是系统来给分配任务</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用协程实现异步消费"><a href="#使用协程实现异步消费" class="headerlink" title="使用协程实现异步消费"></a>使用协程实现异步消费</h4><p>协程本质上就是一个线程，以前线程任务的切换是由操作系统控制的，遇到I/O自动切换，现在我们用协程的目的就是较少操作系统切换的开销（开关线程，创建寄存器、堆栈等，在他们之间进行切换等），在我们自己的程序里面来控制任务的切换<br>优点：</p><ol><li>协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</li><li>单线程内就可以实现并发的效果，最大限度地利用cpu</li></ol><p>缺点：</p><ol><li>协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程</li><li>协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 协程也是一种单线程，只不过是用户来给分配任务</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># 创建事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 运行事件循环，直到dojob运行结束</span></span><br><span class="line">res = loop.run_until_complete(dojob())</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;异步消费可以使用很多方式来实现，我们今天就来说说异步消费的其中三种实现方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;线程池&lt;/li&gt;
&lt;li&gt;协程&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="异步" scheme="https://www.hr915.xyz/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现消息队列(Queue)</title>
    <link href="https://www.hr915.xyz/id_21/"/>
    <id>https://www.hr915.xyz/id_21/</id>
    <published>2018-08-27T09:53:36.000Z</published>
    <updated>2021-04-06T08:47:35.725Z</updated>
    
    <content type="html"><![CDATA[<ul><li>相关问题：</li></ul><p><strong>问</strong>：为什么能用列表推导式的时候不用普通for循环？<br><strong>答</strong>：列表推导式比普通for循环性能好</p><a id="more"></a><p><strong>问</strong>：什么是lambda表达式？怎么用？<br><strong>答</strong>：lambda表达式又被称为匿名函数，一般在执行简单的逻辑时使用<br>lambda x:x<em>x   lambda关键字 x变量 x</em>x逻辑<br>注意：lambda的使用大量简化了代码，使代码简练清晰。但是值得注意的是，这会在一定程度上降低代码的可读性。还有lambda内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。<br><strong>问</strong>：redis列表里只能存字符串，如果想存别的类型有什么办法？<br><strong>答</strong>：使用eval()</p><blockquote><p>eval() 原样输出字符串，将字符串强转成它包含的数据类型<br>例: a = “[1,2,3]”(字符串)<br>    a = eval(a)<br>结果：a=<a href="%E5%88%97%E8%A1%A8">1,2,3</a></p></blockquote><p><strong>加权队列</strong>：举个例子吧，在银行窗口办理业务的时候需要先取号==放进队列，然后排队等待。<br>但是这只是普通用户。如果有金卡用户取号，那么金卡用户的业务就可以插队==加权，先行办理金卡用户的业务<br>加权需要用到排序，并且Celery并没有加权这一功能<br>上代码！</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先进行方法封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="comment"># 队列遵循先进先出的原则</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, **redis_kwargs</span>):</span></span><br><span class="line">        <span class="comment"># **kwarys不定长参数  用于可传可不传的参数 </span></span><br><span class="line">        <span class="comment"># kwargs是用来传键值对，args 一般用来传列表和元祖</span></span><br><span class="line">        <span class="comment"># self.__变量名：使用双下划线开头的变量是私有变量，在类外不可以被调用</span></span><br><span class="line">        <span class="comment"># redis的默认参数为：host='localhost', port=6379, db=0， 其中db为定义redis的第几个库</span></span><br><span class="line">        self.__db = redis.Redis(**redis_kwargs, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.key = name</span><br><span class="line">        <span class="comment"># llen:获取列表长度</span></span><br><span class="line">        <span class="comment"># lrange:获取列表指定范围内的元素</span></span><br><span class="line">        self.r_len = self.__db.llen(self.key)</span><br><span class="line">        self.l = self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">tuple</span></span>):</span></span><br><span class="line">        <span class="comment"># rpush:在列表中添加一个或多个值</span></span><br><span class="line">        self.__db.rpush(self.key, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.__db.lrange(self.key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 排序用来加权(加权是celery没有的)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 因为redis里存的是字符串，而排序的依据是元组中最后一个元素为int,所以使用-2下标</span></span><br><span class="line">        <span class="comment"># 此处可用eval </span></span><br><span class="line">        self.l = <span class="built_in">sorted</span>(self.l, key=<span class="keyword">lambda</span> x: x[-<span class="number">2</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># pop(0):移出并获取列表的第一个元素</span></span><br><span class="line">        <span class="comment"># lrem 根据第二个参数的值，移除列表中与参数相等的元素。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.l:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        item = self.l.pop(<span class="number">0</span>)</span><br><span class="line">        self.__db.lrem(self.key, item, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 用来清空列表</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.delete(self.key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    m = MyQueue(<span class="string">'que'</span>)</span><br><span class="line">    <span class="comment"># 添加到redis</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 列表推导式</span></span><br><span class="line">    [m.push(i,i+<span class="number">1</span>,i+<span class="number">2</span>) <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) i++]</span><br><span class="line">    <span class="comment"># 将添加进去的数据排序 </span></span><br><span class="line">    m.sort()</span><br><span class="line">    <span class="comment"># 删除排序后列表中的第一个元素</span></span><br><span class="line">    m.pop()</span><br><span class="line">    <span class="comment"># 清空列表</span></span><br><span class="line">    m.clear()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;相关问题：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问&lt;/strong&gt;：为什么能用列表推导式的时候不用普通for循环？&lt;br&gt;&lt;strong&gt;答&lt;/strong&gt;：列表推导式比普通for循环性能好&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="redis" scheme="https://www.hr915.xyz/tags/redis/"/>
    
    <category term="队列" scheme="https://www.hr915.xyz/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis封禁账号30分钟</title>
    <link href="https://www.hr915.xyz/id_20/"/>
    <id>https://www.hr915.xyz/id_20/</id>
    <published>2018-08-26T11:43:58.000Z</published>
    <updated>2021-03-29T08:27:01.250Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题</strong>： 账号锁定问题  五分钟以内输错五次密码，锁定账号30分钟</p><ul><li>相关问题：</li></ul><p><strong>问</strong>：用户登录都有哪些校验方式？<br><strong>答</strong>：</p><ul><li>用户名和密码 what you know (容易被破解，ant-desgin被黑删库)</li><li>用户名和密钥(token)  what you have (gitee可以通过密钥来提交代码)</li><li>用户名和实体  who you are  (人脸识别但成本过高)<a id="more"></a></li></ul><p><strong>问</strong>：为什么要使用redis解决这个问题而不用mysql呢<br><strong>答</strong>：因为使用redis更简单，redis会自动计算时间，mysql需要自己手动将时间入库，比较复杂<br><strong>问题解答</strong>：</p><ul><li><p>第一步 先判断 用户名+balck 这个key 是否存在</p><ul><li>存在 意味着已经被锁定 所以直接返回</li><li> 不存在 继续执行</li></ul></li><li><p>第二步 向数据库进行请求  登录</p><ul><li>登录成功 直接返回    </li><li>登录不成功 进行redis操作</li></ul></li><li><p>第三步 判断是否是第一次输入错误</p><ul><li>是 使用incrby进行redis自动累加存储，并expire设置过期时间5分钟，返回输入错误</li><li>否 使用get取出用户名这个key的值，判断是否等于5 次<ul><li>是 使用set将 用户名+’black’ 这个key存入redis 并expire设置过期时间30分钟，返回账户已锁定</li><li>否 使用set用户名更新这个key，并返回输入错误 </li></ul></li></ul></li></ul><p>OK，上代码</p><h3 id="首先-对redis命令进行封装"><a href="#首先-对redis命令进行封装" class="headerlink" title="首先 对redis命令进行封装"></a>首先 对redis命令进行封装</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 封装redis</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRedis</span>:</span></span><br><span class="line">    <span class="comment"># 用来定义属性和变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, **redis_kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.__变量名：使用双下划线开头的变量是私有变量，在类外不可以被调用</span></span><br><span class="line">        <span class="comment"># **kwarys不定长参数  用于可传可不传的参数</span></span><br><span class="line">        <span class="comment"># kwargs是用来传键值对，args 用来传列表和元祖</span></span><br><span class="line"></span><br><span class="line">        self.__db = redis.Redis(**redis_kwargs)</span><br><span class="line"></span><br><span class="line">        self.key = key</span><br><span class="line">    <span class="comment"># 向redis存储数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__db.<span class="built_in">set</span>(self.key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从redis取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__db.get(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># redis 自动累加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incrby</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__db.incrby(self.key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># redis设置键过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expire</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__db.expire(self.key, value)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="然后写登录视图"><a href="#然后写登录视图" class="headerlink" title="然后写登录视图"></a>然后写登录视图</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        username = request.data.get(<span class="string">"username"</span>)</span><br><span class="line">        password = request.data.get(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一步 先判断 用户名+balck 这个key 是否存在</span></span><br><span class="line">        <span class="comment"># 存在 意味着已经被锁定 所以直接返回</span></span><br><span class="line">        r = redis.Redis()</span><br><span class="line">        <span class="keyword">if</span> r.get(username + <span class="string">'black'</span>):</span><br><span class="line">            print(r.get(username + <span class="string">'black'</span>))</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"账户已锁定，请等待30分钟后重试"</span>})</span><br><span class="line">        <span class="comment"># 不存在 登录</span></span><br><span class="line">        user = UserModel.objects.<span class="built_in">filter</span>(username=username, password=password).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"登录成功"</span>, <span class="string">"code"</span>: <span class="number">200</span>})</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 判断是否输入错误过</span></span><br><span class="line">            <span class="comment"># 没有</span></span><br><span class="line">            <span class="keyword">if</span> r.get(username) == <span class="literal">None</span>:</span><br><span class="line">                r.incrby(username, <span class="number">1</span>)</span><br><span class="line">                print(<span class="string">"第一次输入错误"</span>)</span><br><span class="line">                r.expire(username, <span class="number">300</span>)</span><br><span class="line">                <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"第一次输入错误"</span>, <span class="string">"code"</span>: <span class="number">400</span>})</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = <span class="built_in">int</span>(r.get(username))</span><br><span class="line">                <span class="comment"># 输入错误五次，加入黑名单</span></span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">5</span>:</span><br><span class="line">                    r.<span class="built_in">set</span>(username + <span class="string">'black'</span>, <span class="number">30</span>)</span><br><span class="line">                    r.expire(username + <span class="string">'black'</span>, <span class="number">1800</span>)</span><br><span class="line">                    <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"输入次数以上限，请30分钟后重试"</span>, <span class="string">'code'</span>: <span class="number">200</span>})</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r.<span class="built_in">set</span>(username, value + <span class="number">1</span>)</span><br><span class="line">                    print(r.get(username))</span><br><span class="line">                    <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"用户名或密码错误，请重新输入"</span>, <span class="string">'code'</span>: <span class="number">400</span>})</span><br></pre></td></tr></tbody></table></figure><h3 id="OK-问题解决了。"><a href="#OK-问题解决了。" class="headerlink" title="OK,问题解决了。"></a>OK,问题解决了。</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;： 账号锁定问题  五分钟以内输错五次密码，锁定账号30分钟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相关问题：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问&lt;/strong&gt;：用户登录都有哪些校验方式？&lt;br&gt;&lt;strong&gt;答&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户名和密码 what you know (容易被破解，ant-desgin被黑删库)&lt;/li&gt;
&lt;li&gt;用户名和密钥(token)  what you have (gitee可以通过密钥来提交代码)&lt;/li&gt;
&lt;li&gt;用户名和实体  who you are  (人脸识别但成本过高)&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="https://www.hr915.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>接口测试中的异步调用和异步写入文件</title>
    <link href="https://www.hr915.xyz/id_19/"/>
    <id>https://www.hr915.xyz/id_19/</id>
    <published>2018-08-26T07:21:32.000Z</published>
    <updated>2021-03-29T08:27:01.255Z</updated>
    
    <content type="html"><![CDATA[<p>异步调用：<br>异步方法必须async 关键字声明<br>所有其他方法，耗时任务都需要加上await关键字，await必须依靠async<br>with用来建立工作流和关闭流对象</p><a id="more"></a><h4 id="异步发送100次请求"><a href="#异步发送100次请求" class="headerlink" title="异步发送100次请求"></a>异步发送100次请求</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步调用</span></span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url = <span class="string">'http://127.0.0.1:8000/p8/user'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">client</span>):</span></span><br><span class="line">    r = <span class="keyword">await</span> client.get(url)</span><br><span class="line">    print(r.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># 100 次调用</span></span><br><span class="line">        task_list = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            req = request(client)</span><br><span class="line">            task = asyncio.create_task(req)</span><br><span class="line">            task_list.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*task_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="comment"># 结束</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'异步：发送100次请求，耗时：<span class="subst">{end - start}</span>'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="异步写文件"><a href="#异步写文件" class="headerlink" title="异步写文件"></a>异步写文件</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">await</span> f.write(<span class="string">"欢迎来到缅甸北部\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">"10000.txt"</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 列表推导式调用，更快，效率更高 </span></span><br><span class="line">        task = [asyncio.create_task(write(f)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]</span><br><span class="line">        <span class="comment"># 普通列表 相对于列表推导式要慢一点</span></span><br><span class="line">        <span class="comment"># test_list = []</span></span><br><span class="line">        <span class="comment"># for i in range(10000):</span></span><br><span class="line">        <span class="comment">#     w = write(f)</span></span><br><span class="line">        <span class="comment">#     task = asyncio.create_task(w)</span></span><br><span class="line">        <span class="comment">#     test_list.append(task)</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(fun())</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"执行了%d秒"</span> % (end - start))</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;异步调用：&lt;br&gt;异步方法必须async 关键字声明&lt;br&gt;所有其他方法，耗时任务都需要加上await关键字，await必须依靠async&lt;br&gt;with用来建立工作流和关闭流对象&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="异步" scheme="https://www.hr915.xyz/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>用户注册</title>
    <link href="https://www.hr915.xyz/id_18/"/>
    <id>https://www.hr915.xyz/id_18/</id>
    <published>2018-08-24T10:56:32.000Z</published>
    <updated>2021-03-29T08:27:01.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="用户注册功能"><a href="#用户注册功能" class="headerlink" title="用户注册功能"></a>用户注册功能</h4><p>需求：实现用户注册功能，并将用户注册信息保存到磁盘文件中，用户注册时至少给定：用户名和密码<br>注意：用户名使用了唯一索引，不可重复</p><a id="more"></a><ul><li>相关问题：</li></ul><p><strong>问</strong>：唯一索引干嘛用的 为什么用？<br><strong>答</strong>：指的是某个字段不能出现重复的值，比如身份证列，手机号。<br>使用唯一索引避免了注册时需要进数据库查询是否有重复的一次IO操作，节省时间，提高效率</p><p>OK 上代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">register</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        username = request.data.get(<span class="string">"username"</span>)</span><br><span class="line">        password = request.data.get(<span class="string">"password"</span>)</span><br><span class="line">        leave = request.data.get(<span class="string">"leave"</span>)       <span class="comment"># 用户等级</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            UserModel.objects.create(username=username, password=password, leave=leave)</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"添加成功"</span>, <span class="string">"code"</span>: <span class="number">200</span>})</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">return</span> Response({<span class="string">"msg"</span>: <span class="string">"该用户已存在"</span>, <span class="string">"code"</span>: <span class="number">400</span>})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;用户注册功能&quot;&gt;&lt;a href=&quot;#用户注册功能&quot; class=&quot;headerlink&quot; title=&quot;用户注册功能&quot;&gt;&lt;/a&gt;用户注册功能&lt;/h4&gt;&lt;p&gt;需求：实现用户注册功能，并将用户注册信息保存到磁盘文件中，用户注册时至少给定：用户名和密码&lt;br&gt;注意：用户名使用了唯一索引，不可重复&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.hr915.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="django" scheme="https://www.hr915.xyz/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>redis键空间事件</title>
    <link href="https://www.hr915.xyz/id_17/"/>
    <id>https://www.hr915.xyz/id_17/</id>
    <published>2018-07-19T12:46:25.000Z</published>
    <updated>2021-03-29T08:27:01.234Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的键空间通知(keyspace notifications)功能是自2.8.0版本开始加入的，客户端可以通过订阅/发布(Pub/Sub)机制，接收那些以某种方式改变了Redis数据空间的事件通知。比如：所有改变给定key的命令；所有经过lpush操作的key；所有在0号数据库中过期的key等等。<br>通知是通过Redis的订阅/发布机制发送的，因此，所有支持订阅/发布功能的客户端都可在无需调整的情况下，使用键空间通知功能。</p><a id="more"></a><h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>因键空间通知功能需要耗费一定的CPU时间，因此默认情况下，该功能是关闭的。<br>可以通过修改配置文件redis.conf，或者通过config set notify-keyspace-events KEA，来启用或关闭该功能。</p><p>KEA字符串表示启用了所有可能的事件。要查看每个字符的含义，请参考文档：<a href="https://redis.io/topics/notifications">https://redis.io/topics/notifications</a><br>CLI 可以在特殊模式下工作，允许您订阅一个通道以接收消息。</p><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p> 针对改变Redis数据空间的每个操作，键空间通知都会发送两类不同的事件。<br>比如在0号数库中，执行del mykey操作，将会触发两个消息，等价于执行下面两个publish命令：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey <span class="keyword">del</span></span><br><span class="line">PUBLISH __keyevent@0__:<span class="keyword">del</span> mykey</span><br></pre></td></tr></tbody></table></figure><p>一个频道发布0号数据库中，所有针对mykey键执行的操作，这类事件，以keyspace为前缀，称为keyspace通知；<br> 另一个频道发布0号数据库中，所有成功执行del操作的键，这类事件，以keyevent为前缀，称为keyevent通知；<br> 在上面的例子中，当执行del  mykey时，会发生：<br> a：keyspace频道的订阅者会收到消息，消息中包含键执行的操作的名字；<br> b：keyevent频道的订阅者会收到消息，消息中包含执行某种操作的键的名字；<br> 可以通过配置，使Redis仅发送某一类我们感兴趣的通知。</p><h4 id="案例-1-for-example-："><a href="#案例-1-for-example-：" class="headerlink" title="案例 1 for example ："></a>案例 1 for example ：</h4><ol><li>Redis发布所有通知，客户端A订阅所有消息：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;  psubscribe __key*@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li><li>  然后，在客户端B上执行set和del命令：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></tbody></table></figure></li><li>此时客户端A的打印就变成了这样： <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyevent@0__:set"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"liu"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"del"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyevent@0__:del"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"liu"</span></span><br></pre></td></tr></tbody></table></figure></li><li>可见，针对每一个操作，客户端A都收到了两种消息，分别是keyspace和keyevent消息。</li></ol><h4 id="案例-2-for-example-："><a href="#案例-2-for-example-：" class="headerlink" title="案例 2 for example ："></a>案例 2 for example ：</h4><ol><li>使Redis仅发布keyspace通知，而客户端A订阅所有消息类型：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KA</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; psubscribe __key*@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li><li>然后，在客户端B上执行set和del命令：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></li><li>此时客户端A的打印就变成了这样： <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"del"</span></span><br></pre></td></tr></tbody></table></figure></li><li>可见，尽管客户端A订阅了所有消息，但是Redis仅发布了keyspace事件。<br>而且，在客户端B上执行了两次del操作，而只有第一个del成功执行了，从而产生了一个事件。</li></ol><h4 id="案例-3-for-example-："><a href="#案例-3-for-example-：" class="headerlink" title="案例 3 for example ："></a>案例 3 for example ：</h4><ol><li>Redis发布所有通知，客户端A仅订阅keyspace消息<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; psubscribe __keyspace@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyspace@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li><li>然后，在客户端B上执行set和del命令：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></li><li>此时客户端A的打印就变成了这样： <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyspace@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyspace@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"del"</span></span><br></pre></td></tr></tbody></table></figure></li><li>可见，针对每一个操作，客户端A只收到了keyspace消息</li></ol><h4 id="案例-4-for-example-："><a href="#案例-4-for-example-：" class="headerlink" title="案例 4 for example ："></a>案例 4 for example ：</h4><ol><li>Redis仅发布字符串特定类型的通知，客户端A订阅所有类型的消息<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> notify-keyspace-events KE$</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; psubscribe __key*@0__:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li><li>在客户端B上，分别执行lpush，set和del命令：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush <span class="built_in">list</span> liu hui ran</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> liu HR</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> liu</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li><li>此时客户端A的打印就变成了这样：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyspace@0__:liu"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"set"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__key*@0__:*"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"__keyevent@0__:set"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"liu"</span></span><br></pre></td></tr></tbody></table></figure></li><li>可见，针对字符串，产生了keyspace和keyevent类型的消息，而针对列表的lpush命令并没有产生消息，而且，del命令是非特定类型的命令，也没有产生消息。</li></ol><h4 id="OK-本文到此结束"><a href="#OK-本文到此结束" class="headerlink" title="OK,本文到此结束"></a>OK,本文到此结束</h4><p>要查看所有有可能的时间，请参考文档：<a href="https://redis.io/topics/notifications">https://redis.io/topics/notifications</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis的键空间通知(keyspace notifications)功能是自2.8.0版本开始加入的，客户端可以通过订阅/发布(Pub/Sub)机制，接收那些以某种方式改变了Redis数据空间的事件通知。比如：所有改变给定key的命令；所有经过lpush操作的key；所有在0号数据库中过期的key等等。&lt;br&gt;通知是通过Redis的订阅/发布机制发送的，因此，所有支持订阅/发布功能的客户端都可在无需调整的情况下，使用键空间通知功能。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="https://www.hr915.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis发布订阅</title>
    <link href="https://www.hr915.xyz/id_16/"/>
    <id>https://www.hr915.xyz/id_16/</id>
    <published>2018-07-18T12:46:25.000Z</published>
    <updated>2021-03-29T08:27:01.252Z</updated>
    
    <content type="html"><![CDATA[<p>Redis提供了发布订阅功能，跟消息中间件是类似的，可以用于消息的传输，Redis提供了一组命令可以让开发者实现“发布/订阅”模式 (publish/subscribe) ，该模式同样可以实现进程间的消息传递。<br>它的实现原理是发布/订阅模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道，而发布者可以向指定的 频道发送消息，所有订阅此频道的订阅者都会收到该消息。</p><a id="more"></a><h4 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h4><p><img src="/id_16/01.png" alt="发布订阅"></p><h4 id="redis-消息订阅和发布命令："><a href="#redis-消息订阅和发布命令：" class="headerlink" title="redis 消息订阅和发布命令："></a>redis 消息订阅和发布命令：</h4><ol><li>psubscribe pattern [pattern…] ：订阅一个或多个给定模式的 频道</li><li>punsubscribe [pattern [pttern…]]：退订所有频道给定模式的频道</li><li>pubsub subcommand [argument [argument…]]：查看订阅与发布系统状态</li><li>publish channel message：将信息发送到指定的频道</li><li>subscribe channel [channel…]：订阅给定的一个或多个频道信息。</li><li>unsubscribe [channel [channel…]]：指退订给定的频道。</li></ol><h4 id="案例-for-example-："><a href="#案例-for-example-：" class="headerlink" title="案例 for example ："></a>案例 for example ：</h4><p><strong>注意</strong>：需要打开两个小黑窗口哦！</p><ol><li><p>一次订阅多个频道 c1,c2,c3 (subscribe c1 c2 c3)<br><img src="/id_16/02.png" alt="订阅多个频道"></p></li><li><p>消息发布，向c2频道发布消息 (publish c2 hello-redis)<br><img src="/id_16/03.png" alt="向指定频道发布消息"></p></li><li><p>订阅给定模式的频道，通配符* (psubscribe new*)<br><img src="/id_16/04.png" alt="订阅特定模式的频道"></p></li><li><p>发布消息 (publish new1 redis-hello)<br><img src="/id_16/05.png" alt="发布消息"></p></li></ol><h4 id="OK-本文到此结束"><a href="#OK-本文到此结束" class="headerlink" title="OK 本文到此结束"></a>OK 本文到此结束</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis提供了发布订阅功能，跟消息中间件是类似的，可以用于消息的传输，Redis提供了一组命令可以让开发者实现“发布/订阅”模式 (publish/subscribe) ，该模式同样可以实现进程间的消息传递。&lt;br&gt;它的实现原理是发布/订阅模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道，而发布者可以向指定的 频道发送消息，所有订阅此频道的订阅者都会收到该消息。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.hr915.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="https://www.hr915.xyz/tags/redis/"/>
    
  </entry>
  
</feed>
